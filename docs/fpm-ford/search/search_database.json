var tipuesearch = {"pages":[{"title":" M_anything ","text":"M_anything Name M_anything(3fm) - [M_anything] procedures that use polymorphism to allow arguments of different types generically\n   (LICENSE:MIT) Synopsis use M_anything , only : anyscalar_to_string use M_anything , only : anyscalar_to_int64 use M_anything , only : anyscalar_to_real use M_anything , only : anyscalar_to_real128 use M_anything , only : anyscalar_to_double use M_anything , only : anything_to_bytes use M_anything , only : anyinteger_to_string use M_anything , only : bytes_to_anything use M_anything , only : empty , assignment ( = ) Description Generic routines are generally more efficient than casting but can generate a\n  large amount of duplicate code. These procedures show how to use casting \n  instead for input parameters. Future versions of Fortran are planned to allow\n  for templating as another alternative. anyscalar_to_string     convert intrinsic types to a a string\nanyscalar_to_int64      convert integer parameter of any kind to 64-bit integer\nanyscalar_to_real       convert integer or real parameter of any kind to real\nanyscalar_to_real128    convert integer or real parameter of any kind to real128\nanyscalar_to_double     convert integer or real parameter of any kind to doubleprecision\nanyinteger_to_string    convert integer parameter of any kind to string\nanything_to_bytes       convert anything to bytes\nempty                   create an empty array Example Sample program: program demo_anyscalar_to_double use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squareall ( 2_int8 ) write ( * , * ) squareall ( 2_int16 ) write ( * , * ) squareall ( 2_int32 ) write ( * , * ) squareall ( 2_int64 ) write ( * , * ) squareall ( 2.0_real32 ) write ( * , * ) squareall ( 2.0_real64 ) write ( * , * ) squareall ( 2.0_real128 ) contains function squareall ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squareall end program demo_anyscalar_to_double Results: 4.00000000000000\n        4.00000000000000\n        4.00000000000000\n        4.00000000000000\n        4.00000000000000\n        4.00000000000000\n        4.00000000000000 Author John S. Urban License MIT Building the Module Using make(1) git clone https : // github . com / urbanjost / M_anything . git cd M_anything / src # change Makefile if not using one of the listed compilers # for gfortran make clean make F90 = gfortran gfortran # for ifort make clean make F90 = ifort ifort # REMOVE REFERENCES TO 128 - BIT REALS # for nvfortran make clean make F90 = nvfortran nvfortran This will compile the Fortran module and basic example\nprogram that exercise the routine. Build and Test with fpm Alternatively, download the github repository and build it with\n   fpm ( as described at Fortran Package Manager ) bash\n        git clone https://github.com/urbanjost/M_anything.git\n        cd M_anything\n        fpm run \"*\"\n        fpm run --example \"*\"\n        fpm test or just list it as a dependency in your fpm.toml project file. [dependencies] M_anything = { git = \"https://github.com/urbanjost/M_anything.git\" } Documentation User a simple index to the man-pages in HTML form for the routines A single page that uses javascript to combine all the HTML\n     descriptions of the man-pages is at BOOK_M_anything . There are man-pages in the repository download in the docs/ directory\n     that may be installed on ULS (Unix-Like Systems). manpages.zip manpages.tgz CHANGELOG provides a history of significant changes Developer ford(1) output . doxygen(1) output . github action status — Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"header – M_anything","text":"subroutine header(line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Source Code subroutine header ( line ) character ( len =* ), intent ( in ) :: line write ( * , '(*(a))' ) '#' , repeat ( '=' , len ( line ) + 2 ), '#' write ( * , '(\"|\",1x,a,1x,\"|\")' ) line write ( * , '(*(a))' ) '#' , repeat ( '=' , len ( line ) + 2 ), '#' end subroutine header","tags":"","url":"proc/header.html"},{"title":"squarei – M_anything","text":"function squarei(invalue) result(dvalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Variables Type Visibility Attributes Name Initial doubleprecision, public :: invalue_local Source Code function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squarei","tags":"","url":"proc/squarei.html"},{"title":"squareall – M_anything","text":"function squareall(invalue) result(dvalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Variables Type Visibility Attributes Name Initial doubleprecision, public :: invalue_local Source Code function squareall ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squareall","tags":"","url":"proc/squareall.html"},{"title":"minall – M_anything","text":"function minall(a, b, c, d, e, f, g) result(value) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: a class(*), intent(in) :: b class(*), intent(in) :: c class(*), intent(in) :: d class(*), intent(in) :: e class(*), intent(in) :: f class(*), intent(in) :: g Return Value real(kind=qp) Source Code function minall ( a , b , c , d , e , f , g ) result ( value ) use M_anything , only : x => anyscalar_to_real128 class ( * ), intent ( in ) :: a , b , c , d , e , f , g real ( kind = qp ) :: value value = min ( x ( a ), x ( b ), x ( c ), x ( d ), x ( e ), x ( f ), x ( g ) ) end function minall","tags":"","url":"proc/minall.html"},{"title":"check_ints – M_anything","text":"subroutine check_ints(answer, ints) Arguments Type Intent Optional Attributes Name integer, intent(in) :: answer integer, intent(in), allocatable :: ints (:) Source Code subroutine check_ints ( answer , ints ) integer , intent ( in ), allocatable :: ints (:) integer , intent ( in ) :: answer !  if mask test fails, change database status for specified entry to -1 and stop program, else continue if ( allocated ( ints )) then call unit_check ( 'empty' , size ( ints ). eq . answer , 'size is' , answer ) endif end subroutine check_ints","tags":"","url":"proc/check_ints.html"},{"title":"check_strs – M_anything","text":"subroutine check_strs(answer, strs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: answer character(len=:), intent(in), allocatable :: strs (:) Variables Type Visibility Attributes Name Initial integer, public :: k Source Code subroutine check_strs ( answer , strs ) integer , intent ( in ) :: answer character ( len = :), allocatable , intent ( in ) :: strs (:) integer k if ( allocated ( strs ) ) then if ( unit_check_level . gt . 0 ) then print * , \"strs: val = \" , ( strs ( k ) // \" \" , k = 1 , size ( strs ) ) print * , \"      len_elem = \" , len ( strs ( 1 )) endif call unit_check ( 'empty' , size ( strs ). eq . answer , 'size is' , answer ) endif end subroutine check_strs","tags":"","url":"proc/check_strs.html"},{"title":"test_anyinteger_to_string – M_anything","text":"subroutine test_anyinteger_to_string() Arguments None Source Code subroutine test_anyinteger_to_string () call unit_check_start ( 'anyinteger_to_string' , msg = '' ) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int8 )) . eq . '127' , huge ( 0_int8 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int16 )). eq . '32767' , huge ( 0_int16 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int32 )). eq . '2147483647' , huge ( 0_int32 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int64 )). eq . '9223372036854775807' , huge ( 0_int64 )) call unit_check_done ( 'anyinteger_to_string' , msg = '' ) end subroutine test_anyinteger_to_string","tags":"","url":"proc/test_anyinteger_to_string.html"},{"title":"test_anyscalar_to_double – M_anything","text":"subroutine test_anyscalar_to_double() Arguments None Variables Type Visibility Attributes Name Initial real, public :: infinity character(len=*),parameter :: line=’infinity’ character(len=8), public :: line = 'infinity' Source Code subroutine test_anyscalar_to_double () real :: infinity !!character(len=*),parameter :: line='infinity' character ( len = 8 ) :: line = 'infinity' read ( line , * ) infinity call unit_check_start ( 'anyscalar_to_double' , msg = '' ) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int8 )) . eq . huge ( 0_int8 ), huge ( 0_int8 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int16 )) . eq . huge ( 0_int16 ), huge ( 0_int16 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int32 )) . eq . huge ( 0_int32 ), huge ( 0_int32 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int64 )) . eq . huge ( 0_int64 ), huge ( 0_int64 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real32 )) . eq . huge ( 0.0_real32 ), huge ( 0.0_real32 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real64 )) . eq . huge ( 0.0_real64 ), huge ( 0.0_real64 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real128 )) . eq . infinity , huge ( 0.0_real128 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( 123 4.0_real128 ) . eq . 123 4.0_real128 , 123 4.0_real128 ) call unit_check_done ( 'anyscalar_to_double' , msg = '' ) end subroutine test_anyscalar_to_double","tags":"","url":"proc/test_anyscalar_to_double.html"},{"title":"test_anyscalar_to_int64 – M_anything","text":"subroutine test_anyscalar_to_int64() Arguments None Source Code subroutine test_anyscalar_to_int64 () call unit_check_start ( 'anyscalar_to_int64' , msg = '' ) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int8 )) . eq . 127_int64 , huge ( 0_int8 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int16 )). eq . 32767_int64 , huge ( 0_int16 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int32 )). eq . 2147483647_int64 , huge ( 0_int32 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int64 )). eq . 9223372036854775807_int64 , huge ( 0_int64 )) call unit_check_done ( 'anyscalar_to_int64' , msg = '' ) end subroutine test_anyscalar_to_int64","tags":"","url":"proc/test_anyscalar_to_int64.html"},{"title":"test_anyscalar_to_real – M_anything","text":"subroutine test_anyscalar_to_real() Arguments None Variables Type Visibility Attributes Name Initial real, public :: infinity character(len=*),parameter :: line=’infinity’ character(len=8), public :: line = 'infinity' Source Code subroutine test_anyscalar_to_real () real :: infinity !!character(len=*),parameter :: line='infinity' character ( len = 8 ) :: line = 'infinity' read ( line , * ) infinity call unit_check_start ( 'anyscalar_to_real' , msg = '' ) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int8 )) . eq . real ( huge ( 0_int8 )), huge ( 0_int8 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int16 )) . eq . real ( huge ( 0_int16 )), huge ( 0_int16 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int32 )) . eq . real ( huge ( 0_int32 )), huge ( 0_int32 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int64 )) . eq . real ( huge ( 0_int64 )), huge ( 0_int64 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real32 )) . eq . real ( huge ( 0.0_real32 )), huge ( 0.0_real32 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real64 )) . eq . infinity , huge ( 0.0_real64 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real128 )). eq . infinity , huge ( 0.0_real128 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( 123 4.0_real64 ) . eq . 123 4.0_real64 , 123 4.0_real64 ) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( 123 4.0_real128 ) . eq . 123 4.0_real128 , 123 4.0_real128 ) call unit_check_done ( 'anyscalar_to_real' , msg = '' ) end subroutine test_anyscalar_to_real","tags":"","url":"proc/test_anyscalar_to_real.html"},{"title":"test_anything_to_bytes – M_anything","text":"subroutine test_anything_to_bytes() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j Source Code subroutine test_anything_to_bytes () integer :: i , j call unit_check_start ( 'anything_to_bytes' , msg = '' ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int8 )) . eq . transfer ( huge ( 0_int8 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int16 )) . eq . transfer ( huge ( 0_int16 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int32 )) . eq . transfer ( huge ( 0_int32 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int64 )) . eq . transfer ( huge ( 0_int64 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real32 )) . eq . transfer ( huge ( 0.0_real32 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real64 )) . eq . transfer ( huge ( 0.0_real64 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real128 )) . eq . transfer ( huge ( 0.0_real128 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( 'this is a string' ) . eq . transfer ( 'this is a string' , 'A' )) ) call unit_check ( 'anything_to_bytes' , any (& & anything_to_bytes ([ 'aaaaaaaaaa' , 'bbbbbbbbbb' ]) . eq . transfer ([ 'aaaaaaaaaa' , 'bbbbbbbbbb' ], 'A' )), 'check against transfer' ) call unit_check ( 'anything_to_bytes' , size ( anything_to_bytes ( 'this is a string' )) . eq . len ( 'this is a string' ), 'check byte count' ) i = size ( anything_to_bytes ([ 'aaaaaaaaaa' , 'bbbbbbbbbb' ])) j = len ( 'aaaaaaaaaabbbbbbbbbb' ) call unit_check ( 'anything_to_bytes' , i . eq . j , 'expected' , i , 'got' , j , 'check array byte count' ) call unit_check_done ( 'anything_to_bytes' , msg = '' ) end subroutine test_anything_to_bytes","tags":"","url":"proc/test_anything_to_bytes.html"},{"title":"test_empty – M_anything","text":"subroutine test_empty() use M_anything, only : empty, assignment(=) Arguments None Variables Type Visibility Attributes Name Initial integer, public :: answer character(len=:), public, allocatable :: c (:) doubleprecision, public, allocatable :: d (:) integer, public, allocatable :: i (:) integer, public, allocatable :: ints (:) real, public, allocatable :: r (:) character(len=:), public, allocatable :: strs (:) Source Code subroutine test_empty !!use M_anything, only : empty, assignment(=) implicit none doubleprecision , allocatable :: d (:) integer , allocatable :: i (:) real , allocatable :: r (:) character ( len = :), allocatable :: c (:) integer , allocatable :: ints (:) character (:), allocatable :: strs (:) integer :: answer call unit_check_start ( 'empty' ) !  register an entry for specified name in database with status of zero (0) d = empty r = empty i = empty c = empty call unit_check ( 'empty' , size ( d ). eq . 0 , 'checking double' ) call unit_check ( 'empty' , size ( r ). eq . 0 , 'checking real' ) call unit_check ( 'empty' , size ( i ). eq . 0 , 'checking integer' ) call unit_check ( 'empty' , size ( c ). eq . 0 , 'checking character' ) ints = empty answer = 0 call check_ints ( answer , ints ) ints = [ 1 , 2 , 3 ] answer = 3 call check_ints ( answer , ints ) call unit_check ( 'empty' , all ( ints . eq .[ 1 , 2 , 3 ]), msg = 'normal allocation' ) ints = empty answer = 0 call check_ints ( answer , ints ) strs = empty answer = 0 call check_strs ( answer , strs ) strs = [ \"apple\" , \"orang\" , \"banan\" ] answer = 3 call check_strs ( answer , strs ) call unit_check ( 'empty' , all ( strs . eq .[ \"apple\" , \"orang\" , \"banan\" ]), msg = 'normal allocation' ) strs = empty answer = 0 call check_strs ( answer , strs ) call unit_check_done ( 'empty' ) end subroutine test_empty","tags":"","url":"proc/test_empty.html"},{"title":"anyinteger_to_string – M_anything","text":"public impure function anyinteger_to_string(int) result(out) NAME anyinteger_to_string ( 3 f ) - [ M_anything ] convert integer of any kind to a string ( LICENSE : MIT ) SYNOPSIS impure function anyinteger_to_string(intin) result(str)\n\n character(len=:),allocatable :: anyinteger_to_string\n class(*),intent(in)          :: intin DESCRIPTION Converts an integer value to a string representing the value.\nThis function allows arguments of different INTEGER types as input. OPTIONS VALUEIN  INTEGER input argument to be converted to a string.\n         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64. RESULTS The value of VALUIN converted to a CHARACTER string. EXAMPLE Sample program program demo_anyinteger_to_string use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use M_anything , only : itoc => anyinteger_to_string implicit none write ( * , * ) itoc ( huge ( 0 _int8 )) , ' => 127 ' write ( * , * ) itoc ( huge ( 0 _int16 )) , ' => 32767 ' write ( * , * ) itoc ( huge ( 0 _int32 )) , ' => 2147483647 ' write ( * , * ) itoc ( huge ( 0 _int64 )) , ' => 9223372036854775807 ' , huge ( 0 _int64 ) write ( * , * ) itoc ( - ( huge ( 0 _int64 ) - 1 )) , ' => -9223372036854775806 ' end program demo_anyinteger_to_string Results: 127 => 127 32767 => 32767 2147483647 => 2147483647 9223372036854775807 => 9223372036854775807 - 9223372036854775806 => - 9223372036854775806 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name class(*), intent(in) :: int Return Value character(len=:), allocatable Source Code impure function anyinteger_to_string ( int ) result ( out ) ! ident_8=\"@(#) M_anything anyinteger_to_string(3f) function that converts an integer value to a character string\" class ( * ), intent ( in ) :: int character ( len = :), allocatable :: out integer , parameter :: maxlen = 32 ! assumed more than enough characters for largest input value integer :: i , k integer ( kind = int64 ) :: intval integer ( kind = int64 ) :: int_local integer :: str ( maxlen ) integer , parameter :: dig0 = ichar ( '0' ) integer , parameter :: minus = ichar ( '-' ) int_local = anyscalar_to_int64 ( int ) ! convert input to largest integer type intval = abs ( int_local ) do i = 1 , maxlen ! generate digits from smallest significant digit to largest str ( i ) = dig0 + mod ( intval , 10_int64 ) intval = intval / 10 if ( intval == 0 ) exit enddo if ( int_local < 0 ) then ! now make sure the sign is correct i = i + 1 str ( i ) = minus endif allocate ( character ( len = i ) :: out ) do k = i , 1 , - 1 ! have all the digits in reverse order, now flip them and convert to a string out ( i - k + 1 : i - k + 1 ) = char ( str ( k )) enddo end function anyinteger_to_string","tags":"","url":"proc/anyinteger_to_string.html"},{"title":"anyscalar_to_double – M_anything","text":"public pure elemental function anyscalar_to_double(valuein) result(d_out) NAME anyscalar_to_double ( 3 f ) - [ M_anything ] convert integer or real parameter of any kind to doubleprecision ( LICENSE : MIT ) SYNOPSIS pure elemental function anyscalar_to_double(valuein) result(d_out)\n\n class(*),intent(in)  :: valuein\n doubleprecision      :: d_out DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used to create other procedures that can take many\nscalar arguments as input options. OPTIONS VALUEIN  input argument of a procedure to convert to type DOUBLEPRECISION.\n         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64,\n         kind=real32, kind=real64, or kind=real128 RESULTS D_OUT    The value of VALUIN converted to doubleprecision (assuming\n         it is actually in the range of type DOUBLEPRECISION). EXAMPLE Sample program program demo_anyscalar_to_double use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2 _int8 ) write ( * , * ) squarei ( 2 _int16 ) write ( * , * ) squarei ( 2 _int32 ) write ( * , * ) squarei ( 2 _int64 ) write ( * , * ) squarei ( 2 . 0 _real32 ) write ( * , * ) squarei ( 2 . 0 _real64 ) write ( * , * ) squarei ( 2 . 0 _real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ) , intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_double AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value doubleprecision Source Code pure elemental function anyscalar_to_double ( valuein ) result ( d_out ) ! ident_4=\"@(#) M_anything anyscalar_to_double(3f) convert integer or real parameter of any kind to doubleprecision\" class ( * ), intent ( in ) :: valuein doubleprecision :: d_out #ifdef HAS_REAL128 doubleprecision , parameter :: big = huge ( 0.0d0 ) #endif select type ( valuein ) type is ( integer ( kind = int8 )); d_out = dble ( valuein ) type is ( integer ( kind = int16 )); d_out = dble ( valuein ) type is ( integer ( kind = int32 )); d_out = dble ( valuein ) type is ( integer ( kind = int64 )); d_out = dble ( valuein ) type is ( real ( kind = real32 )); d_out = dble ( valuein ) type is ( real ( kind = real64 )); d_out = dble ( valuein ) #ifdef HAS_REAL128 Type is ( real ( kind = real128 )) !IMPURE! if(valuein > big)then !IMPURE!    write(stderr,'(*(g0,1x))')'*anyscalar_to_double* value too large ',valuein !IMPURE! endif d_out = dble ( valuein ) #endif type is ( logical ); d_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out class default !IMPURE! stop '*M_anything::anyscalar_to_double: unknown type' end select end function anyscalar_to_double","tags":"","url":"proc/anyscalar_to_double.html"},{"title":"anyscalar_to_int64 – M_anything","text":"public impure elemental function anyscalar_to_int64(valuein) result(ii38) NAME anyscalar_to_int64 ( 3 f ) - [ M_anything ] convert intrinsic scalar types to integer ( kind = int64 ) ( LICENSE : MIT ) SYNOPSIS impure elemental function anyscalar_to_int64(valin) result(value)\n\n class(*),intent(in) :: valin\n integer(kind=int64) :: value DESCRIPTION This function uses polymorphism to allow arguments of different types as input . It is typically used to create other procedures that can take many scalar arguments as input options , equivalent to passing the parameter VALUE as int ( VALUE , 0 _int64 ) for integer ; nint ( VALUE , 0 _int64 ) for real values , returning 0 _int64 for . true . and 1 _int64 for logical , and the same as int ( VALUE , 0 _int64 ) for character variables if the character variables represent an integer value . OPTIONS VALUEIN  input argument of a procedure to convert to type INTEGER(KIND=int64). RESULTS The value of VALUIN converted to INTEGER(KIND=INT64). EXAMPLE Sample program program demo_anyscalar_to_int64 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( huge ( 0 _int8 )) , huge ( 0 _int8 ) , & & ' 16129 ' write ( * , * ) squarei ( huge ( 0 _int16 )) , huge ( 0 _int16 ) , & & ' 1073676289 ' write ( * , * ) squarei ( huge ( 0 _int32 )) , huge ( 0 _int32 ) , & & ' 4611686014132420609 ' write ( * , * ) squarei ( huge ( 0 _int64 )) , huge ( 0 _int64 ) , & & ' 85070591730234615847396907784232501249 ' contains ! function squarei ( invalue ) use M_anything , only : anyscalar_to_int64 class ( * ) , intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: squarei invalue_local = anyscalar_to_int64 ( invalue ) squarei = invalue_local * invalue_local end function squarei ! end program demo_anyscalar_to_int64 Results 16129.000000000000 127 !! 16129 1073676289.0000000 32767 !! 1073676289 4.6116860141324206E+018 2147483647 !! 4611686014132420609 8.5070591730234616E+037 9223372036854775807 !! 85070591730234615847396907784232501249 2.8948022309329049E+076 170141183460469231731687303715884105727 !! 28948022309329048855892746252171976962977213799489202546401021394546514198529 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value integer(kind=int64) Source Code impure elemental function anyscalar_to_int64 ( valuein ) result ( ii38 ) ! ident_6=\"@(#) M_anything anyscalar_to_int64(3f) convert parameter of any intrinsic kind to 64-bit integer\" class ( * ), intent ( in ) :: valuein integer ( kind = int64 ) :: ii38 integer :: ios character ( len = 256 ) :: message select type ( valuein ) type is ( integer ( kind = int8 )); ii38 = int ( valuein , kind = int64 ) type is ( integer ( kind = int16 )); ii38 = int ( valuein , kind = int64 ) type is ( integer ( kind = int32 )); ii38 = valuein type is ( integer ( kind = int64 )); ii38 = valuein type is ( real ( kind = real32 )); ii38 = nint ( valuein , kind = int64 ) type is ( real ( kind = real64 )); ii38 = nint ( valuein , kind = int64 ) #ifdef HAS_REAL128 Type is ( real ( kind = real128 )); ii38 = nint ( valuein , kind = int64 ) #endif type is ( logical ); ii38 = merge ( 0_int64 , 1_int64 , valuein ) type is ( character ( len =* )) ; read ( valuein , * , iostat = ios , iomsg = message ) ii38 if ( ios /= 0 ) then write ( stderr , * ) '*anyscalar_to_int64* ERROR: ' // trim ( message ) stop 2 endif class default write ( stderr , * ) '*anyscalar_to_int64* ERROR: unknown input type' stop 3 end select end function anyscalar_to_int64","tags":"","url":"proc/anyscalar_to_int64.html"},{"title":"anyscalar_to_real – M_anything","text":"public pure elemental function anyscalar_to_real(valuein) result(r_out) NAME anyscalar_to_real ( 3 f ) - [ M_anything ] convert integer or real parameter of any kind to real ( LICENSE : MIT ) SYNOPSIS pure elemental function anyscalar_to_real(valuein) result(r_out)\n\n class(*),intent(in)  :: valuein\n real                 :: r_out DESCRIPTION This function uses polymorphism to allow input arguments of different types.\nIt is used to create other procedures that can take\nmany scalar arguments as input options. OPTIONS VALUEIN  input argument of a procedure to convert to type REAL.\n         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64,\n         kind=real32, kind=real64, or kind=real128. RESULTS R_OUT    The value of VALUIN converted to real (assuming it is actually\n         in the range of type REAL). EXAMPLE Sample program program demo_anyscalar_to_real use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2 _int8 ) write ( * , * ) squarei ( 2 _int16 ) write ( * , * ) squarei ( 2 _int32 ) write ( * , * ) squarei ( 2 _int64 ) write ( * , * ) squarei ( 2 . 0 _real32 ) write ( * , * ) squarei ( 2 . 0 _real64 ) write ( * , * ) squarei ( 2 . 0 _real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real class ( * ) , intent ( in ) :: invalue real :: invalue_local real :: dvalue invalue_local = anyscalar_to_real ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_real AUTHOR John S. Urban LICENSE MIT if(valuein > big)then\n   write(stderr, )’ anyscalar_to_real value too large ‘,valuein\nendif\nif(valuein > big)then\n   write(stderr, )’ anyscalar_to_real value too large ‘,valuein\nendif Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value real Source Code pure elemental function anyscalar_to_real ( valuein ) result ( r_out ) ! ident_5=\"@(#) M_anything anyscalar_to_real(3f) convert integer or real parameter of any kind to real\" class ( * ), intent ( in ) :: valuein real :: r_out real , parameter :: big = huge ( 0.0 ) select type ( valuein ) type is ( integer ( kind = int8 )); r_out = real ( valuein ) type is ( integer ( kind = int16 )); r_out = real ( valuein ) type is ( integer ( kind = int32 )); r_out = real ( valuein ) type is ( integer ( kind = int64 )); r_out = real ( valuein ) type is ( real ( kind = real32 )); r_out = real ( valuein ) type is ( real ( kind = real64 )) !!if(valuein > big)then !!   write(stderr,*)'*anyscalar_to_real* value too large ',valuein !!endif r_out = real ( valuein ) #ifdef HAS_REAL128 type is ( real ( kind = real128 )) !!if(valuein > big)then !!   write(stderr,*)'*anyscalar_to_real* value too large ',valuein !!endif r_out = real ( valuein ) #endif type is ( logical ); r_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) r_out end select end function anyscalar_to_real","tags":"","url":"proc/anyscalar_to_real.html"},{"title":"anyscalar_to_real128 – M_anything","text":"public pure elemental function anyscalar_to_real128(valuein) result(d_out) NAME anyscalar_to_real128 ( 3 f ) - [ M_anything ] convert integer or real parameter of any kind to real128 ( LICENSE : MIT ) SYNOPSIS pure elemental function anyscalar_to_real128(valuein) result(d_out)\n\n class(*),intent(in) :: valuein\n real(kind=128)      :: d_out DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used to create other procedures that can take many\nscalar arguments as input options. OPTIONS VALUEIN  input argument of a procedure to convert to type REAL128.\n         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64,\n         kind=real32, kind=real64, or kind=real128 RESULTS D_OUT    The value of VALUIN converted to REAL128 (assuming\n         it is actually in the range of type REAL128). EXAMPLE Sample program program demo_anyscalar_to_real128 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2 _int8 ) write ( * , * ) squarei ( 2 _int16 ) write ( * , * ) squarei ( 2 _int32 ) write ( * , * ) squarei ( 2 _int64 ) write ( * , * ) squarei ( 2 . 0 _real32 ) write ( * , * ) squarei ( 2 . 0 _real64 ) write ( * , * ) squarei ( 2 . 0 _real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real128 class ( * ) , intent ( in ) :: invalue real ( kind = real128 ) :: invalue_local real ( kind = real128 ) :: dvalue invalue_local = anyscalar_to_real128 ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_real128 AUTHOR John S. Urban LICENSE MIT stop ‘*M_anything::anyscalar_to_real128: unknown type’ Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value real(kind=real128) Source Code pure elemental function anyscalar_to_real128 ( valuein ) result ( d_out ) ! ident_3=\"@(#) M_anything anyscalar_to_real128(3f) convert integer or real parameter of any kind to real128\" class ( * ), intent ( in ) :: valuein real ( kind = real128 ) :: d_out character ( len = 3 ) :: readable select type ( valuein ) type is ( integer ( kind = int8 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int16 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int32 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int64 )); d_out = real ( valuein , kind = real128 ) type is ( real ( kind = real32 )); d_out = real ( valuein , kind = real128 ) type is ( real ( kind = real64 )); d_out = real ( valuein , kind = real128 ) Type is ( real ( kind = real128 )); d_out = valuein type is ( logical ); d_out = merge ( 0.0_real128 , 1.0_real128 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out class default readable = 'NaN' read ( readable , * ) d_out !!stop '*M_anything::anyscalar_to_real128: unknown type' end select end function anyscalar_to_real128","tags":"","url":"proc/anyscalar_to_real128.html"},{"title":"anyscalar_to_string – M_anything","text":"public pure function anyscalar_to_string(gen0, gen1, gen2, gen3, gen4, gen5, gen6, gen7, gen8, gen9, gena, genb, genc, gend, gene, genf, geng, genh, geni, genj, sep) NAME anyscalar_to_string ( 3 f ) - [ M_anything ] converts up to twenty standard scalar type values to a string ( LICENSE : MIT ) SYNOPSIS Syntax : pure function anyscalar_to_string ( g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep ) class (*), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class (*), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj character ( len =*), intent ( in ), optional :: sep character , len =(:), allocatable :: anyscalar_to_string DESCRIPTION anyscalar_to_string(3f) builds a space-separated string from up to twenty scalar values. OPTIONS g[0-9a-j]   optional value to print the value of after the message. May\n            be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION,\n            COMPLEX, or CHARACTER.\n\n            Optionally, all the generic values can be\n            single-dimensioned arrays. Currently, mixing scalar\n            arguments and array arguments is not supported.\n\nsep         separator string used between values. Defaults to a space. RETURNS anyscalar_to_string     a representation of the input as a string EXAMPLES Sample program: program demo_anyscalar_to_string use M_anything , only : anyscalar_to_string implicit none character ( len = : ) , allocatable :: pr character ( len = : ) , allocatable :: frmt integer :: biggest pr = anyscalar_to_string ( ' HUGE(3f) integers ' , huge ( 0 ) , & & ' and real ' , huge ( 0 . 0 ) , ' and double ' , huge ( 0 . 0 d0 )) write ( * , ' (a) ' ) pr pr = anyscalar_to_string ( ' real            : ' , huge ( 0 . 0 ) , 0 . 0 , 12345 . 6789 , tiny ( 0 . 0 ) ) write ( * , ' (a) ' ) pr pr = anyscalar_to_string ( ' doubleprecision : ' , huge ( 0 . 0 d0 ) , 0 . 0 d0 , 12345 . 6789 d0 , tiny ( 0 . 0 d0 ) ) write ( * , ' (a) ' ) pr pr = anyscalar_to_string ( ' complex         : ' , cmplx ( huge ( 0 . 0 ) , tiny ( 0 . 0 )) ) write ( * , ' (a) ' ) pr ! create a format on the fly biggest = huge ( 0 ) frmt = anyscalar_to_string ( ' (*(i ' , int ( log10 ( real ( biggest ))) , ' :,1x)) ' , sep = '' ) write ( * , * ) ' format= ' , frmt ! although it will often work , using anyscalar_to_string ( 3 f ) ! in an I / O statement is not recommended ! because if an error occurs anyscalar_to_string ( 3 f ) will try ! to write while part of an I / O statement ! which not all compilers can handle and is currently non - standard write ( * , * ) anyscalar_to_string ( ' program will now stop ' ) end program demo_anyscalar_to_string Output HUGE(3f) integers 2147483647 and real 3.40282347E+38\nand double 1.7976931348623157E+308\nreal            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38\ndoubleprecision : 1.7976931348623157E+308 0.0000000000000000\n12345.678900000001 2.2250738585072014E-308\ncomplex         : (3.40282347E+38,1.17549435E-38)\n format=(*(i9:,1x))\n program will now stop AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: gen0 class(*), intent(in), optional :: gen1 class(*), intent(in), optional :: gen2 class(*), intent(in), optional :: gen3 class(*), intent(in), optional :: gen4 class(*), intent(in), optional :: gen5 class(*), intent(in), optional :: gen6 class(*), intent(in), optional :: gen7 class(*), intent(in), optional :: gen8 class(*), intent(in), optional :: gen9 class(*), intent(in), optional :: gena class(*), intent(in), optional :: genb class(*), intent(in), optional :: genc class(*), intent(in), optional :: gend class(*), intent(in), optional :: gene class(*), intent(in), optional :: genf class(*), intent(in), optional :: geng class(*), intent(in), optional :: genh class(*), intent(in), optional :: geni class(*), intent(in), optional :: genj character(len=*), intent(in), optional :: sep Return Value character(len=:), allocatable Source Code pure function anyscalar_to_string ( gen0 , gen1 , gen2 , gen3 , gen4 , gen5 , gen6 , gen7 , gen8 , gen9 , & & gena , genb , genc , gend , gene , genf , geng , genh , geni , genj , & & sep ) ! ident_7=\"@(#) M_anything anyscalar_to_string(3fp) writes a message to a string composed of any standard scalar types\" class ( * ), intent ( in ), optional :: gen0 , gen1 , gen2 , gen3 , gen4 class ( * ), intent ( in ), optional :: gen5 , gen6 , gen7 , gen8 , gen9 class ( * ), intent ( in ), optional :: gena , genb , genc , gend , gene class ( * ), intent ( in ), optional :: genf , geng , genh , geni , genj character ( len = :), allocatable :: anyscalar_to_string character ( len = 4096 ) :: line integer :: istart integer :: increment character ( len =* ), intent ( in ), optional :: sep character ( len = :), allocatable :: sep_local if ( present ( sep )) then increment = len ( sep ) + 1 sep_local = sep else increment = 2 sep_local = ' ' endif istart = 1 line = '' if ( present ( gen0 )) call print_generic ( gen0 , line , istart , increment , sep_local ) if ( present ( gen1 )) call print_generic ( gen1 , line , istart , increment , sep_local ) if ( present ( gen2 )) call print_generic ( gen2 , line , istart , increment , sep_local ) if ( present ( gen3 )) call print_generic ( gen3 , line , istart , increment , sep_local ) if ( present ( gen4 )) call print_generic ( gen4 , line , istart , increment , sep_local ) if ( present ( gen5 )) call print_generic ( gen5 , line , istart , increment , sep_local ) if ( present ( gen6 )) call print_generic ( gen6 , line , istart , increment , sep_local ) if ( present ( gen7 )) call print_generic ( gen7 , line , istart , increment , sep_local ) if ( present ( gen8 )) call print_generic ( gen8 , line , istart , increment , sep_local ) if ( present ( gen9 )) call print_generic ( gen9 , line , istart , increment , sep_local ) if ( present ( gena )) call print_generic ( gena , line , istart , increment , sep_local ) if ( present ( genb )) call print_generic ( genb , line , istart , increment , sep_local ) if ( present ( genc )) call print_generic ( genc , line , istart , increment , sep_local ) if ( present ( gend )) call print_generic ( gend , line , istart , increment , sep_local ) if ( present ( gene )) call print_generic ( gene , line , istart , increment , sep_local ) if ( present ( genf )) call print_generic ( genf , line , istart , increment , sep_local ) if ( present ( geng )) call print_generic ( geng , line , istart , increment , sep_local ) if ( present ( genh )) call print_generic ( genh , line , istart , increment , sep_local ) if ( present ( geni )) call print_generic ( geni , line , istart , increment , sep_local ) if ( present ( genj )) call print_generic ( genj , line , istart , increment , sep_local ) anyscalar_to_string = trim ( line ) contains !=================================================================================================================================== pure subroutine print_generic ( generic , line , istart , increment , sep ) class ( * ), intent ( in ) :: generic character ( len = 4096 ), intent ( inout ) :: line integer , intent ( inout ) :: istart integer , intent ( in ) :: increment character ( len =* ), intent ( in ) :: sep select type ( generic ) type is ( integer ( kind = int8 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int16 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int32 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int64 )); write ( line ( istart :), '(i0)' ) generic type is ( real ( kind = real32 )); write ( line ( istart :), '(1pg0)' ) generic type is ( real ( kind = real64 )); write ( line ( istart :), '(1pg0)' ) generic #ifdef HAS_REAL128 type is ( real ( kind = real128 )); write ( line ( istart :), '(1pg0)' ) generic #endif type is ( logical ); write ( line ( istart :), '(l1)' ) generic type is ( character ( len =* )); write ( line ( istart :), '(a)' ) trim ( generic ) type is ( complex ); write ( line ( istart :), '(\"(\",1pg0,\",\",1pg0,\")\")' ) generic end select istart = len_trim ( line ) + increment line = trim ( line ) // sep end subroutine print_generic end function anyscalar_to_string","tags":"","url":"proc/anyscalar_to_string.html"},{"title":"anything_to_bytes – M_anything","text":"public interface anything_to_bytes Module Procedures private  function anything_to_bytes_arr(anything) result(chars) NAME anything_to_bytes ( 3 f ) - [ M_anything ] convert standard types to bytes ( character ( len = 1 ) :: array ( : )) ( LICENSE : MIT ) SYNOPSIS function anything_to_bytes(anything) result ( chars ) class ( * ), intent ( in ) :: anything or class ( * ), intent ( in ) :: anything (:) character ( len = 1 ), allocatable :: chars (:) DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used to create other procedures that can take many\nargument types as input options and convert them to a single type\nto simplify storing arbitrary data, to simplify generating data\nhashes, ... OPTIONS VALUEIN  input array or scalar to convert to type CHARACTER(LEN=1).\n         May be of KIND INTEGER(kind=int8), INTEGER(kind=int16),\n         INTEGER(kind=int32), INTEGER(kind=int64),\n         REAL(kind=real32, REAL(kind=real64),\n         REAL(kind=real128), complex, or CHARACTER(len=*) RETURN CHARS    The returned value is an array of bytes (character(len=1)). EXAMPLE Sample program program demo_anything_to_bytes use M_anything , only : anything_to_bytes implicit none integer :: i write ( * , ' (/,4(1x,z2.2)) ' ) anything_to_bytes ( [ ( i * i , i = 1 , 10 ) ] ) write ( * , ' (/,4(1x,z2.2)) ' ) anything_to_bytes ( [ 11 . 11 , 22 . 22 , 33 . 33 ] ) write ( * , ' (/,4(1x,z2.2)) ' ) anything_to_bytes ( ' This is a string ' ) end program demo_anything_to_bytes Expected output 01 00 00 00\n    04 00 00 00\n    09 00 00 00\n    10 00 00 00\n    19 00 00 00\n    24 00 00 00\n    31 00 00 00\n    40 00 00 00\n    51 00 00 00\n    64 00 00 00\n\n    8F C2 31 41\n    8F C2 B1 41\n    EC 51 05 42\n\n    54 68 69 73\n    20 69 73 20\n    61 20 73 74\n    72 69 6E 67 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) Return Value character(len=1), allocatable, (:) private  function anything_to_bytes_scalar(anything) result(chars) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything Return Value character(len=1), allocatable, (:)","tags":"","url":"interface/anything_to_bytes.html"},{"title":"assignment(=) – M_anything","text":"public interface assignment(=) Module Procedures private  subroutine ints_empty_(x, emp) NAME empty ( 3 f ) - [ M_anything ] set an allocatable array to zero ( LICENSE : MIT ) SYNOPSIS use M_anything , only : empty , assignment ( = ) DESCRIPTION A convenience routine that sets an array to an empty set. EXAMPLE Sample program: program demo_empty_ use M_anything , only : empty , assignment ( = ) integer , allocatable :: ints ( : ) character ( : ), allocatable :: strs ( : ) real , allocatable :: reals ( : ) ints = empty write ( * , * ) size ( ints ) write ( * , * )' give them some size ...' reals = [ 1.0 , 2.0 , 3.0 ] ints = [ 1 , 2 , 3 ] strs = [ character ( len = 10 ) :: \"one\" , \"two\" , \"three\" , \"four\" ] write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) ints = empty reals = empty strs = empty write ( * , * )' back to empty ...' write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) end program demo_empty_ Expected output: >             0\n>   give them some size ...\n>             3\n>             3\n>             4\n>   back to empty ...\n>             0\n>             0\n>             0 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private  subroutine reals_empty_(x, emp) Arguments Type Intent Optional Attributes Name real, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private  subroutine doubles_empty_(x, emp) Arguments Type Intent Optional Attributes Name doubleprecision, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private  subroutine strings_empty_(x, emp) Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp","tags":"","url":"interface/assignment(=).html"},{"title":"bytes_to_anything – M_anything","text":"public interface bytes_to_anything Module Procedures private  subroutine bytes_to_anything_arr(chars, anything) NAME bytes_to_anything ( 3 f ) - [ M_anything ] convert bytes ( character ) len = 1 ) :: array ( : )) to standard types ( LICENSE : MIT ) SYNOPSIS subroutine bytes_to_anything(chars,anything) character(len=1),allocatable :: chars(:)\nclass(*) :: anything DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used to create other procedures that can take many\nargument types as input options and convert them to a single type\nto simplify storing arbitrary data, to simplify generating data\nhashes, ... OPTIONS CHARS     The input value is an array of bytes (character(len=1)). RETURN ANYTHING  May be of KIND INTEGER(kind=int8), INTEGER(kind=int16),\n          INTEGER(kind=int32), INTEGER(kind=int64),\n          REAL(kind=real32, REAL(kind=real64),\n          REAL(kind=real128), complex, or CHARACTER(len=*) EXAMPLE Sample program program demo_bytes_to_anything use , intrinsic :: ISO_FORTRAN_ENV , only : & CSZ => CHARACTER_STORAGE_SIZE & stderr => error_unit use :: M_anything , only : bytes_to_anything , anything_to_bytes implicit none character ( len = 1 ) , allocatable :: chars ( : ) character ( len = : ) , allocatable :: line character ( len = : ) , allocatable :: lines ( : ) integer :: ints ( 10 ) integer :: i , int integer , allocatable :: somesize ( : ) call header ( ' integer array to bytes ' ) chars = anything_to_bytes ( [ ( i * i , i = 1 , size ( ints )) ] ) write ( * , ' (/,4(1x,z2.2)) ' ) chars call bytes_to_anything ( chars , ints ) write ( * , * ) ' and bytes back to integer array ' write ( * , ' (/,*(g0,1x)) ' ) ints call header ( ' integer scalar to bytes ' ) chars = anything_to_bytes ( 1234 ) write ( * , ' (/,\"CHARS=\",*(1x,z2.2)) ' ) chars call bytes_to_anything ( chars , int ) write ( * , * ) ' and bytes back to integer scalar ' write ( * , ' (/,\"INT=\",*(g0,1x)) ' ) int call header ( ' a string ' ) chars = anything_to_bytes ( ' this is a string ' ) write ( * , ' (/,\"CHARS=\",*(1x,z2.2)) ' ) chars write ( * , ' (/,\"CHARS=\",*(g0,1x)) ' ) chars ! string must be long enough to hold chars line = repeat ( ' ' , size ( chars )) call bytes_to_anything ( chars , line ) write ( * , ' (/,\"LINE=\",*(g0,1x)) ' ) line call header ( & ' a string array (have to know length or size you wish to return to) ' ) chars = anything_to_bytes ( [ character ( len = 4 ) :: ' a ' , ' bb ' , ' ccc ' ] ) write ( * , ' (/,\"CHARS=\",*(1x,z2.2)) ' ) chars write ( * , ' (/,\"CHARS=\",*(g0,1x)) ' ) chars ! string must be long enough to hold chars , and have enough elements ! can just return as a scalar string if unknown length lines = [ repeat ( ' ' , size ( chars )) ] ! of for that matter just work with the chars ( 1 ) array , ! but assuming know length in this case lines = [ ( repeat ( ' # ' , 4 ) , i = 1 , 3 ) ] call bytes_to_anything ( chars , lines ) write ( * , ' (/,\"LINES=\",*(\"[\",g0,\"]\",1x:)) ' ) lines call header ( ' calculating size to allocate for non-string types ' ) ! make sure array is of sufficient size to hold results chars = anything_to_bytes ( [ 11 , 22 , 33 , 44 ] ) write ( * , ' (/,\"CHARS=\",*(1x,z2.2)) ' ) chars allocate ( somesize ( size ( chars ) / ( storage_size ( 0 ) / CSZ ))) call bytes_to_anything ( chars , somesize ) write ( * , ' (/,\"SOMESIZE=\",*(\"[\",g0,\"]\",1x:)) ' ) somesize contains subroutine header ( line ) character ( len =* ) , intent ( in ) :: line write ( * , ' (*(a)) ' ) ' # ' , repeat ( ' = ' , len ( line ) + 2 ) , ' # ' write ( * , ' (\"|\",1x,a,1x,\"|\") ' ) line write ( * , ' (*(a)) ' ) ' # ' , repeat ( ' = ' , len ( line ) + 2 ) , ' # ' end subroutine header end program demo_bytes_to_anything Results: > # ======================== # > | integer array to bytes | > # ======================== # > > 01 00 00 00 > 04 00 00 00 > 09 00 00 00 > 10 00 00 00 > 19 00 00 00 > 24 00 00 00 > 31 00 00 00 > 40 00 00 00 > 51 00 00 00 > 64 00 00 00 > and bytes back to integer array > > 1 4 9 16 25 36 49 64 81 100 > # ========================= # > | integer scalar to bytes | > # ========================= # > > CHARS = D2 04 00 00 > and bytes back to integer scalar > > INT = 1234 > # ========== # > | a string | > # ========== # > > CHARS = 74 68 69 73 20 69 73 20 61 20 73 74 72 69 6 E 67 > > CHARS = t h i s i s a s t r i n g > > LINE = this is a string > # ==================================================================== # > | a string array ( have to know length or size you wish to return to ) | > # ==================================================================== # > > CHARS = 61 20 20 20 62 62 20 20 63 63 63 20 > > CHARS = a b b c c c > > LINES = [ a ] [ bb ] [ ccc ] > # =================================================== # > | calculating size to allocate for non - string types | > # =================================================== # > > CHARS = 0 B 00 00 00 16 00 00 00 21 00 00 00 2 C 00 00 00 > > SOMESIZE = [ 11 ] [ 22 ] [ 33 ] [ 44 ] AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: chars (:) class(*), intent(out) :: anything (:) private  subroutine bytes_to_anything_scalar(chars, anything) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: chars (:) class(*), intent(out) :: anything","tags":"","url":"interface/bytes_to_anything.html"},{"title":"get_type – M_anything","text":"public interface get_type Module Procedures private  function get_type_arr(anything) result(chars) NAME get_type ( 3 f ) - [ M_anything ] return array of strings containing type names of arguments ( LICENSE : MIT ) SYNOPSIS function get_type(anything) result ( chars ) class ( * ), intent ( in ) :: anything or class ( * ), intent ( in ) :: anything (..) character ( len =:), allocatable :: chars DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used by other procedures that can take many\nargument types as input options. OPTIONS VALUEIN input array or scalar to return type of May be of KIND INTEGER ( kind = int8 ) , INTEGER ( kind = int16 ) , INTEGER ( kind = int32 ) , INTEGER ( kind = int64 ) , REAL ( kind = real32 , REAL ( kind = real64 ) , REAL ( kind = real128 ) , complex , or CHARACTER ( len =* ) RETURN CHARS    The returned value is an array of names EXAMPLE Sample program program demo_get_type use M_anything , only : get_type implicit none integer :: i write ( * , * ) get_type ( [ ( i * i , i = 1 , 10 ) ] ) write ( * , * ) get_type ( [ 11 . 11 , 22 . 22 , 33 . 33 ] ) write ( * , * ) get_type ( ' This is a string ' ) write ( * , * ) get_type ( 30 . 0 d0 ) end program demo_get_type Results: int32\n real32\n character\n real64 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) Return Value character(len=20) private impure elemental function get_type_scalar(anything) result(chars) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything Return Value character(len=20)","tags":"","url":"interface/get_type.html"},{"title":"squarei – M_anything","text":"function squarei(invalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Variables Type Visibility Attributes Name Initial doubleprecision, public :: invalue_local Source Code function squarei ( invalue ) use M_anything , only : anyscalar_to_int64 class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: squarei invalue_local = anyscalar_to_int64 ( invalue ) squarei = invalue_local * invalue_local end function squarei","tags":"","url":"proc/squarei~2.html"},{"title":"squarei – M_anything","text":"function squarei(invalue) result(dvalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value real Variables Type Visibility Attributes Name Initial real, public :: invalue_local Source Code function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue invalue_local = anyscalar_to_real ( invalue ) dvalue = invalue_local * invalue_local end function squarei","tags":"","url":"proc/squarei~3.html"},{"title":"squarei – M_anything","text":"function squarei(invalue) result(dvalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value real Variables Type Visibility Attributes Name Initial real, public, parameter :: biggest = sqrt(real(0.0, kind=real128)) real, public :: invalue_local Source Code function squarei ( invalue ) result ( dvalue ) ! square an integer value generically use M_anything , only : anyscalar_to_real implicit none class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue real , parameter :: biggest = sqrt ( real ( 0.0 , kind = real128 )) invalue_local = anyscalar_to_real ( invalue ) !if(invalue_local.gt.biggest)then !   write(*,*)'ERROR:*squarei* input value to big=',invalue_local !endif dvalue = invalue_local * invalue_local end function squarei","tags":"","url":"proc/squarei~4.html"},{"title":"M_anything – M_anything","text":"NAME M_anything(3fm) - [M_anything::INTRO] procedures that use polymorphism to allow arguments of different types generically\n(LICENSE:MIT) SYNOPSIS use M_anything , only : anyscalar_to_string use M_anything , only : anyscalar_to_int64 use M_anything , only : anyscalar_to_real use M_anything , only : anyscalar_to_real128 use M_anything , only : anyscalar_to_double use M_anything , only : anything_to_bytes use M_anything , only : anyinteger_to_string use M_anything , only : get_type use M_anything , only : bytes_to_anything use M_anything , only : empty , assignment ( = ) DESCRIPTION anyscalar_to_string convert intrinsic type to string anyscalar_to_int64 convert integer or real of any kind to 64 - bit integer anyscalar_to_real convert integer or real of any kind to real anyscalar_to_real128 convert integer or real of any kind to real128 anyscalar_to_double convert integer or real of any kind to doubleprecision anything_to_bytes convert anything to bytes anyinteger_to_string convert integer to string get_type return array of strings containing type names of arguments empty create an empty array EXAMPLE At the cost of casting to a different type these functions can\n (among other uses such as in linked lists) allow for an alternative\n to duplicating code using generic procedure methods. For example,\n the following SQUAREALL function can take many input types and return a\n DOUBLEPRECISION value (it is a trivial example for demonstration purposes,\n and does not check for overflow, etc.).: Sample program program demo_M_anything use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squareall ( 2 _int8 ) write ( * , * ) squareall ( 2 _int16 ) write ( * , * ) squareall ( 2 _int32 ) write ( * , * ) squareall ( 2 _int64 ) write ( * , * ) squareall ( 2 . 0 _real32 ) write ( * , * ) squareall ( 2 . 0 _real64 ) write ( * , * ) squareall ( 2 . 0 _real128 ) contains function squareall ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ) , intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squareall end program demo_M_anything Results: 4.00000000000000\n   4.00000000000000\n   4.00000000000000\n   4.00000000000000\n   4.00000000000000\n   4.00000000000000\n   4.00000000000000 AUTHOR John S. Urban LICENSE MIT ,input_unit,output_unit\npublic setany subroutine setany(anything,default,answer) $@(#) M_anything::setany(3fp): set absent parameter to default value class( ),intent(in),optional     :: anything\nclass( ),intent(in)              :: default\nclass(*),intent(out),allocatable :: answer\nif(present(anything))then\n   answer=anything\nelse\n   answer=default\nendif\nend subroutine setany Uses iso_fortran_env Variables Type Visibility Attributes Name Initial type(Empty_t), public :: empty singleton Interfaces public        interface anything_to_bytes private  function anything_to_bytes_arr(anything) result(chars) NAME anything_to_bytes ( 3 f ) - [ M_anything ] convert standard types to bytes ( character ( len = 1 ) :: array ( : )) ( LICENSE : MIT ) SYNOPSIS function anything_to_bytes(anything) result ( chars ) class ( * ), intent ( in ) :: anything or class ( * ), intent ( in ) :: anything (:) character ( len = 1 ), allocatable :: chars (:) DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used to create other procedures that can take many\nargument types as input options and convert them to a single type\nto simplify storing arbitrary data, to simplify generating data\nhashes, ... OPTIONS VALUEIN  input array or scalar to convert to type CHARACTER(LEN=1).\n         May be of KIND INTEGER(kind=int8), INTEGER(kind=int16),\n         INTEGER(kind=int32), INTEGER(kind=int64),\n         REAL(kind=real32, REAL(kind=real64),\n         REAL(kind=real128), complex, or CHARACTER(len=*) RETURN CHARS    The returned value is an array of bytes (character(len=1)). EXAMPLE Sample program program demo_anything_to_bytes use M_anything , only : anything_to_bytes implicit none integer :: i write ( * , ' (/,4(1x,z2.2)) ' ) anything_to_bytes ( [ ( i * i , i = 1 , 10 ) ] ) write ( * , ' (/,4(1x,z2.2)) ' ) anything_to_bytes ( [ 11 . 11 , 22 . 22 , 33 . 33 ] ) write ( * , ' (/,4(1x,z2.2)) ' ) anything_to_bytes ( ' This is a string ' ) end program demo_anything_to_bytes Expected output 01 00 00 00\n    04 00 00 00\n    09 00 00 00\n    10 00 00 00\n    19 00 00 00\n    24 00 00 00\n    31 00 00 00\n    40 00 00 00\n    51 00 00 00\n    64 00 00 00\n\n    8F C2 31 41\n    8F C2 B1 41\n    EC 51 05 42\n\n    54 68 69 73\n    20 69 73 20\n    61 20 73 74\n    72 69 6E 67 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) Return Value character(len=1), allocatable, (:) private  function anything_to_bytes_scalar(anything) result(chars) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything Return Value character(len=1), allocatable, (:) public        interface assignment(=) private  subroutine ints_empty_(x, emp) NAME empty ( 3 f ) - [ M_anything ] set an allocatable array to zero ( LICENSE : MIT ) SYNOPSIS use M_anything , only : empty , assignment ( = ) DESCRIPTION A convenience routine that sets an array to an empty set. EXAMPLE Sample program: program demo_empty_ use M_anything , only : empty , assignment ( = ) integer , allocatable :: ints ( : ) character ( : ), allocatable :: strs ( : ) real , allocatable :: reals ( : ) ints = empty write ( * , * ) size ( ints ) write ( * , * )' give them some size ...' reals = [ 1.0 , 2.0 , 3.0 ] ints = [ 1 , 2 , 3 ] strs = [ character ( len = 10 ) :: \"one\" , \"two\" , \"three\" , \"four\" ] write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) ints = empty reals = empty strs = empty write ( * , * )' back to empty ...' write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) end program demo_empty_ Expected output: >             0\n>   give them some size ...\n>             3\n>             3\n>             4\n>   back to empty ...\n>             0\n>             0\n>             0 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private  subroutine reals_empty_(x, emp) Arguments Type Intent Optional Attributes Name real, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private  subroutine doubles_empty_(x, emp) Arguments Type Intent Optional Attributes Name doubleprecision, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private  subroutine strings_empty_(x, emp) Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp public        interface bytes_to_anything private  subroutine bytes_to_anything_arr(chars, anything) NAME bytes_to_anything ( 3 f ) - [ M_anything ] convert bytes ( character ) len = 1 ) :: array ( : )) to standard types ( LICENSE : MIT ) SYNOPSIS subroutine bytes_to_anything(chars,anything) character(len=1),allocatable :: chars(:)\nclass(*) :: anything DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used to create other procedures that can take many\nargument types as input options and convert them to a single type\nto simplify storing arbitrary data, to simplify generating data\nhashes, ... OPTIONS CHARS     The input value is an array of bytes (character(len=1)). RETURN ANYTHING  May be of KIND INTEGER(kind=int8), INTEGER(kind=int16),\n          INTEGER(kind=int32), INTEGER(kind=int64),\n          REAL(kind=real32, REAL(kind=real64),\n          REAL(kind=real128), complex, or CHARACTER(len=*) EXAMPLE Sample program program demo_bytes_to_anything use , intrinsic :: ISO_FORTRAN_ENV , only : & CSZ => CHARACTER_STORAGE_SIZE & stderr => error_unit use :: M_anything , only : bytes_to_anything , anything_to_bytes implicit none character ( len = 1 ) , allocatable :: chars ( : ) character ( len = : ) , allocatable :: line character ( len = : ) , allocatable :: lines ( : ) integer :: ints ( 10 ) integer :: i , int integer , allocatable :: somesize ( : ) call header ( ' integer array to bytes ' ) chars = anything_to_bytes ( [ ( i * i , i = 1 , size ( ints )) ] ) write ( * , ' (/,4(1x,z2.2)) ' ) chars call bytes_to_anything ( chars , ints ) write ( * , * ) ' and bytes back to integer array ' write ( * , ' (/,*(g0,1x)) ' ) ints call header ( ' integer scalar to bytes ' ) chars = anything_to_bytes ( 1234 ) write ( * , ' (/,\"CHARS=\",*(1x,z2.2)) ' ) chars call bytes_to_anything ( chars , int ) write ( * , * ) ' and bytes back to integer scalar ' write ( * , ' (/,\"INT=\",*(g0,1x)) ' ) int call header ( ' a string ' ) chars = anything_to_bytes ( ' this is a string ' ) write ( * , ' (/,\"CHARS=\",*(1x,z2.2)) ' ) chars write ( * , ' (/,\"CHARS=\",*(g0,1x)) ' ) chars ! string must be long enough to hold chars line = repeat ( ' ' , size ( chars )) call bytes_to_anything ( chars , line ) write ( * , ' (/,\"LINE=\",*(g0,1x)) ' ) line call header ( & ' a string array (have to know length or size you wish to return to) ' ) chars = anything_to_bytes ( [ character ( len = 4 ) :: ' a ' , ' bb ' , ' ccc ' ] ) write ( * , ' (/,\"CHARS=\",*(1x,z2.2)) ' ) chars write ( * , ' (/,\"CHARS=\",*(g0,1x)) ' ) chars ! string must be long enough to hold chars , and have enough elements ! can just return as a scalar string if unknown length lines = [ repeat ( ' ' , size ( chars )) ] ! of for that matter just work with the chars ( 1 ) array , ! but assuming know length in this case lines = [ ( repeat ( ' # ' , 4 ) , i = 1 , 3 ) ] call bytes_to_anything ( chars , lines ) write ( * , ' (/,\"LINES=\",*(\"[\",g0,\"]\",1x:)) ' ) lines call header ( ' calculating size to allocate for non-string types ' ) ! make sure array is of sufficient size to hold results chars = anything_to_bytes ( [ 11 , 22 , 33 , 44 ] ) write ( * , ' (/,\"CHARS=\",*(1x,z2.2)) ' ) chars allocate ( somesize ( size ( chars ) / ( storage_size ( 0 ) / CSZ ))) call bytes_to_anything ( chars , somesize ) write ( * , ' (/,\"SOMESIZE=\",*(\"[\",g0,\"]\",1x:)) ' ) somesize contains subroutine header ( line ) character ( len =* ) , intent ( in ) :: line write ( * , ' (*(a)) ' ) ' # ' , repeat ( ' = ' , len ( line ) + 2 ) , ' # ' write ( * , ' (\"|\",1x,a,1x,\"|\") ' ) line write ( * , ' (*(a)) ' ) ' # ' , repeat ( ' = ' , len ( line ) + 2 ) , ' # ' end subroutine header end program demo_bytes_to_anything Results: > # ======================== # > | integer array to bytes | > # ======================== # > > 01 00 00 00 > 04 00 00 00 > 09 00 00 00 > 10 00 00 00 > 19 00 00 00 > 24 00 00 00 > 31 00 00 00 > 40 00 00 00 > 51 00 00 00 > 64 00 00 00 > and bytes back to integer array > > 1 4 9 16 25 36 49 64 81 100 > # ========================= # > | integer scalar to bytes | > # ========================= # > > CHARS = D2 04 00 00 > and bytes back to integer scalar > > INT = 1234 > # ========== # > | a string | > # ========== # > > CHARS = 74 68 69 73 20 69 73 20 61 20 73 74 72 69 6 E 67 > > CHARS = t h i s i s a s t r i n g > > LINE = this is a string > # ==================================================================== # > | a string array ( have to know length or size you wish to return to ) | > # ==================================================================== # > > CHARS = 61 20 20 20 62 62 20 20 63 63 63 20 > > CHARS = a b b c c c > > LINES = [ a ] [ bb ] [ ccc ] > # =================================================== # > | calculating size to allocate for non - string types | > # =================================================== # > > CHARS = 0 B 00 00 00 16 00 00 00 21 00 00 00 2 C 00 00 00 > > SOMESIZE = [ 11 ] [ 22 ] [ 33 ] [ 44 ] AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: chars (:) class(*), intent(out) :: anything (:) private  subroutine bytes_to_anything_scalar(chars, anything) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: chars (:) class(*), intent(out) :: anything public        interface get_type private  function get_type_arr(anything) result(chars) NAME get_type ( 3 f ) - [ M_anything ] return array of strings containing type names of arguments ( LICENSE : MIT ) SYNOPSIS function get_type(anything) result ( chars ) class ( * ), intent ( in ) :: anything or class ( * ), intent ( in ) :: anything (..) character ( len =:), allocatable :: chars DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used by other procedures that can take many\nargument types as input options. OPTIONS VALUEIN input array or scalar to return type of May be of KIND INTEGER ( kind = int8 ) , INTEGER ( kind = int16 ) , INTEGER ( kind = int32 ) , INTEGER ( kind = int64 ) , REAL ( kind = real32 , REAL ( kind = real64 ) , REAL ( kind = real128 ) , complex , or CHARACTER ( len =* ) RETURN CHARS    The returned value is an array of names EXAMPLE Sample program program demo_get_type use M_anything , only : get_type implicit none integer :: i write ( * , * ) get_type ( [ ( i * i , i = 1 , 10 ) ] ) write ( * , * ) get_type ( [ 11 . 11 , 22 . 22 , 33 . 33 ] ) write ( * , * ) get_type ( ' This is a string ' ) write ( * , * ) get_type ( 30 . 0 d0 ) end program demo_get_type Results: int32\n real32\n character\n real64 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) Return Value character(len=20) private impure elemental function get_type_scalar(anything) result(chars) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything Return Value character(len=20) Functions public impure function anyinteger_to_string (int) result(out) Sample program Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: int Return Value character(len=:), allocatable public pure elemental function anyscalar_to_double (valuein) result(d_out) Sample program Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value doubleprecision public impure elemental function anyscalar_to_int64 (valuein) result(ii38) Results Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value integer(kind=int64) public pure elemental function anyscalar_to_real (valuein) result(r_out) Sample program Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value real public pure elemental function anyscalar_to_real128 (valuein) result(d_out) Sample program Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value real(kind=real128) public pure function anyscalar_to_string (gen0, gen1, gen2, gen3, gen4, gen5, gen6, gen7, gen8, gen9, gena, genb, genc, gend, gene, genf, geng, genh, geni, genj, sep) Sample program: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: gen0 class(*), intent(in), optional :: gen1 class(*), intent(in), optional :: gen2 class(*), intent(in), optional :: gen3 class(*), intent(in), optional :: gen4 class(*), intent(in), optional :: gen5 class(*), intent(in), optional :: gen6 class(*), intent(in), optional :: gen7 class(*), intent(in), optional :: gen8 class(*), intent(in), optional :: gen9 class(*), intent(in), optional :: gena class(*), intent(in), optional :: genb class(*), intent(in), optional :: genc class(*), intent(in), optional :: gend class(*), intent(in), optional :: gene class(*), intent(in), optional :: genf class(*), intent(in), optional :: geng class(*), intent(in), optional :: genh class(*), intent(in), optional :: geni class(*), intent(in), optional :: genj character(len=*), intent(in), optional :: sep Return Value character(len=:), allocatable","tags":"","url":"module/m_anything.html"},{"title":"demo_anyscalar_to_string – M_anything","text":"Uses M_anything Variables Type Attributes Name Initial integer :: biggest character(len=:), allocatable :: frmt character(len=:), allocatable :: pr Source Code program demo_anyscalar_to_string use M_anything , only : anyscalar_to_string implicit none character ( len = :), allocatable :: pr character ( len = :), allocatable :: frmt integer :: biggest pr = anyscalar_to_string ( 'HUGE(3f) integers' , huge ( 0 ),& & 'and real' , huge ( 0.0 ), 'and double' , huge ( 0.0d0 )) write ( * , '(a)' ) pr pr = anyscalar_to_string ( 'real            :' , huge ( 0.0 ), 0.0 , 1234 5.6789 , tiny ( 0.0 ) ) write ( * , '(a)' ) pr pr = anyscalar_to_string ( 'doubleprecision :' , huge ( 0.0d0 ), 0.0d0 , 1234 5.6789d0 , tiny ( 0.0d0 ) ) write ( * , '(a)' ) pr pr = anyscalar_to_string ( 'complex         :' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) write ( * , '(a)' ) pr ! create a format on the fly biggest = huge ( 0 ) frmt = anyscalar_to_string ( '(*(i' , int ( log10 ( real ( biggest ))), ':,1x))' , sep = '' ) write ( * , * ) 'format=' , frmt ! although it will often work, using anyscalar_to_string(3f) ! in an I/O statement is not recommended ! because if an error occurs anyscalar_to_string(3f) will try ! to write while part of an I/O statement ! which not all compilers can handle and is currently non-standard write ( * , * ) anyscalar_to_string ( 'program will now stop' ) end program demo_anyscalar_to_string","tags":"","url":"program/demo_anyscalar_to_string.html"},{"title":"demo_bytes_to_anything – M_anything","text":"Uses M_anything iso_fortran_env Variables Type Attributes Name Initial character(len=1), allocatable :: chars (:) integer :: i integer :: int integer :: ints (10) character(len=:), allocatable :: line character(len=:), allocatable :: lines (:) integer, allocatable :: somesize (:) Subroutines subroutine header (line) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Source Code program demo_bytes_to_anything use , intrinsic :: ISO_FORTRAN_ENV , only : & CSZ => CHARACTER_STORAGE_SIZE , & stderr => error_unit use :: M_anything , only : bytes_to_anything , anything_to_bytes implicit none character ( len = 1 ), allocatable :: chars (:) character ( len = :), allocatable :: line character ( len = :), allocatable :: lines (:) integer :: ints ( 10 ) integer :: i , int integer , allocatable :: somesize (:) call header ( 'integer array to bytes' ) chars = anything_to_bytes ([( i * i , i = 1 , size ( ints ))]) write ( * , '(/,4(1x,z2.2))' ) chars call bytes_to_anything ( chars , ints ) write ( * , * ) 'and bytes back to integer array' write ( * , '(/,*(g0,1x))' ) ints call header ( 'integer scalar to bytes' ) chars = anything_to_bytes ( 1234 ) write ( * , '(/,\"CHARS=\",*(1x,z2.2))' ) chars call bytes_to_anything ( chars , int ) write ( * , * ) 'and bytes back to integer scalar' write ( * , '(/,\"INT=\",*(g0,1x))' ) int call header ( 'a string' ) chars = anything_to_bytes ( 'this is a string' ) write ( * , '(/,\"CHARS=\",*(1x,z2.2))' ) chars write ( * , '(/,\"CHARS=\",*(g0,1x))' ) chars ! string must be long enough to hold chars line = repeat ( ' ' , size ( chars )) call bytes_to_anything ( chars , line ) write ( * , '(/,\"LINE=\",*(g0,1x))' ) line call header (& 'a string array (have to know length or size you wish to return to)' ) chars = anything_to_bytes ([ character ( len = 4 ) :: 'a' , 'bb' , 'ccc' ]) write ( * , '(/,\"CHARS=\",*(1x,z2.2))' ) chars write ( * , '(/,\"CHARS=\",*(g0,1x))' ) chars ! string must be long enough to hold chars, and have enough elements ! can just return as a scalar string if unknown length lines = [ repeat ( ' ' , size ( chars ))] ! of for that matter just work with the chars(1) array, ! but assuming know length in this case lines = [( repeat ( '#' , 4 ), i = 1 , 3 )] call bytes_to_anything ( chars , lines ) write ( * , '(/,\"LINES=\",*(\"[\",g0,\"]\",1x:))' ) lines call header ( 'calculating size to allocate for non-string types' ) ! make sure array is of sufficient size to hold results chars = anything_to_bytes ([ 11 , 22 , 33 , 44 ]) write ( * , '(/,\"CHARS=\",*(1x,z2.2))' ) chars allocate ( somesize ( size ( chars ) / ( storage_size ( 0 ) / CSZ ))) call bytes_to_anything ( chars , somesize ) write ( * , '(/,\"SOMESIZE=\",*(\"[\",g0,\"]\",1x:))' ) somesize contains subroutine header ( line ) character ( len =* ), intent ( in ) :: line write ( * , '(*(a))' ) '#' , repeat ( '=' , len ( line ) + 2 ), '#' write ( * , '(\"|\",1x,a,1x,\"|\")' ) line write ( * , '(*(a))' ) '#' , repeat ( '=' , len ( line ) + 2 ), '#' end subroutine header end program demo_bytes_to_anything","tags":"","url":"program/demo_bytes_to_anything.html"},{"title":"demo_anyscalar_to_double – M_anything","text":"Uses iso_fortran_env Functions function squarei (invalue) result(dvalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Source Code program demo_anyscalar_to_double use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2_int8 ) write ( * , * ) squarei ( 2_int16 ) write ( * , * ) squarei ( 2_int32 ) write ( * , * ) squarei ( 2_int64 ) write ( * , * ) squarei ( 2.0_real32 ) write ( * , * ) squarei ( 2.0_real64 ) write ( * , * ) squarei ( 2.0_real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_double","tags":"","url":"program/demo_anyscalar_to_double.html"},{"title":"demo_get_type – M_anything","text":"Uses M_anything Variables Type Attributes Name Initial integer :: i Source Code program demo_get_type use M_anything , only : get_type implicit none integer :: i write ( * , * ) get_type ([( i * i , i = 1 , 10 )]) write ( * , * ) get_type ([ 1 1.11 , 2 2.22 , 3 3.33 ]) write ( * , * ) get_type ( 'This is a string' ) write ( * , * ) get_type ( 3 0.0d0 ) end program demo_get_type","tags":"","url":"program/demo_get_type.html"},{"title":"demo_empty_ – M_anything","text":"Uses M_anything Variables Type Attributes Name Initial integer, allocatable :: ints (:) real, allocatable :: reals (:) character(len=:), allocatable :: strs (:) Source Code program demo_empty_ use M_anything , only : empty , assignment ( = ) integer , allocatable :: ints (:) character (:), allocatable :: strs (:) real , allocatable :: reals (:) ints = empty write ( * , * ) size ( ints ) write ( * , * ) 'give them some size ...' reals = [ 1.0 , 2.0 , 3.0 ] ints = [ 1 , 2 , 3 ] strs = [ character ( len = 10 ) :: \"one\" , \"two\" , \"three\" , \"four\" ] write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) ints = empty reals = empty strs = empty write ( * , * ) 'back to empty ...' write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) end program demo_empty_","tags":"","url":"program/demo_empty_.html"},{"title":"demo_M_anything – M_anything","text":"Uses iso_fortran_env Functions function squareall (invalue) result(dvalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Source Code program demo_M_anything use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squareall ( 2_int8 ) write ( * , * ) squareall ( 2_int16 ) write ( * , * ) squareall ( 2_int32 ) write ( * , * ) squareall ( 2_int64 ) write ( * , * ) squareall ( 2.0_real32 ) write ( * , * ) squareall ( 2.0_real64 ) write ( * , * ) squareall ( 2.0_real128 ) contains function squareall ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squareall end program demo_M_anything","tags":"","url":"program/demo_m_anything.html"},{"title":"demo_anyscalar_to_real128 – M_anything","text":"Uses iso_fortran_env Functions function minall (a, b, c, d, e, f, g) result(value) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: a class(*), intent(in) :: b class(*), intent(in) :: c class(*), intent(in) :: d class(*), intent(in) :: e class(*), intent(in) :: f class(*), intent(in) :: g Return Value real(kind=qp) Source Code program demo_anyscalar_to_real128 use , intrinsic :: iso_fortran_env , only : & & sp => real32 , dp => real64 , qp => real128 , & & i8 => int8 , i16 => int16 , i32 => int32 , i64 => int64 implicit none ! call function with various intrinsic numeric types write ( * , * ) minall ( 2_i8 , 3_i16 , 4_i32 , 5_i64 , 6.0_sp , 7.0_dp , 8.0_qp ) write ( * , * ) minall ( 2.0_qp , 2.0_dp , 2.0_sp , 2_i8 , 2_i16 , 2_i32 , 2_i64 ) write ( * , * ) min ( 2.0_qp , 2.0_dp ) write ( * , * ) min ( 2.0_qp , 2.0_dp , 2.0_sp , 2_i8 , 2_i16 , 2_i32 , 2_i64 ) contains function minall ( a , b , c , d , e , f , g ) result ( value ) use M_anything , only : x => anyscalar_to_real128 class ( * ), intent ( in ) :: a , b , c , d , e , f , g real ( kind = qp ) :: value value = min ( x ( a ), x ( b ), x ( c ), x ( d ), x ( e ), x ( f ), x ( g ) ) end function minall end program demo_anyscalar_to_real128","tags":"","url":"program/demo_anyscalar_to_real128.html"},{"title":"M_test_suite_M_anything – M_anything","text":"Uses M_anything M_framework__verify M_framework__msg iso_fortran_env setup\nteardown Subroutines subroutine check_ints (answer, ints) Arguments Type Intent Optional Attributes Name integer, intent(in) :: answer integer, intent(in), allocatable :: ints (:) subroutine check_strs (answer, strs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: answer character(len=:), intent(in), allocatable :: strs (:) subroutine test_anyinteger_to_string () Arguments None subroutine test_anyscalar_to_double () Arguments None subroutine test_anyscalar_to_int64 () Arguments None subroutine test_anyscalar_to_real () Arguments None subroutine test_anything_to_bytes () Arguments None subroutine test_empty () use M_anything, only : empty, assignment(=) Arguments None Source Code program M_test_suite_M_anything use , intrinsic :: ISO_FORTRAN_ENV , only : INT8 , INT16 , INT32 , INT64 !  1           2           4           8 use , intrinsic :: ISO_FORTRAN_ENV , only : REAL32 , REAL64 , REAL128 !  4           8          10 use M_anything , only : anyinteger_to_string , anyscalar_to_int64 use M_anything , only : anyscalar_to_real , anyscalar_to_double , anyscalar_to_real128 use M_anything , only : anything_to_bytes , bytes_to_anything use M_anything , only : empty , assignment ( = ) use M_framework__msg use M_framework__verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_framework__verify , only : unit_check_stop use M_framework__verify , only : unit_check_level implicit none unit_check_level = 0 !! setup call test_anyscalar_to_int64 () call test_anyinteger_to_string () call test_anyscalar_to_real () call test_anyscalar_to_double () call test_anything_to_bytes () call test_empty () !!teardown call unit_check_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_int64 () call unit_check_start ( 'anyscalar_to_int64' , msg = '' ) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int8 )) . eq . 127_int64 , huge ( 0_int8 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int16 )). eq . 32767_int64 , huge ( 0_int16 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int32 )). eq . 2147483647_int64 , huge ( 0_int32 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int64 )). eq . 9223372036854775807_int64 , huge ( 0_int64 )) call unit_check_done ( 'anyscalar_to_int64' , msg = '' ) end subroutine test_anyscalar_to_int64 !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyinteger_to_string () call unit_check_start ( 'anyinteger_to_string' , msg = '' ) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int8 )) . eq . '127' , huge ( 0_int8 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int16 )). eq . '32767' , huge ( 0_int16 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int32 )). eq . '2147483647' , huge ( 0_int32 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int64 )). eq . '9223372036854775807' , huge ( 0_int64 )) call unit_check_done ( 'anyinteger_to_string' , msg = '' ) end subroutine test_anyinteger_to_string !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_double () real :: infinity !!character(len=*),parameter :: line='infinity' character ( len = 8 ) :: line = 'infinity' read ( line , * ) infinity call unit_check_start ( 'anyscalar_to_double' , msg = '' ) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int8 )) . eq . huge ( 0_int8 ), huge ( 0_int8 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int16 )) . eq . huge ( 0_int16 ), huge ( 0_int16 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int32 )) . eq . huge ( 0_int32 ), huge ( 0_int32 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int64 )) . eq . huge ( 0_int64 ), huge ( 0_int64 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real32 )) . eq . huge ( 0.0_real32 ), huge ( 0.0_real32 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real64 )) . eq . huge ( 0.0_real64 ), huge ( 0.0_real64 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real128 )) . eq . infinity , huge ( 0.0_real128 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( 123 4.0_real128 ) . eq . 123 4.0_real128 , 123 4.0_real128 ) call unit_check_done ( 'anyscalar_to_double' , msg = '' ) end subroutine test_anyscalar_to_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_real () real :: infinity !!character(len=*),parameter :: line='infinity' character ( len = 8 ) :: line = 'infinity' read ( line , * ) infinity call unit_check_start ( 'anyscalar_to_real' , msg = '' ) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int8 )) . eq . real ( huge ( 0_int8 )), huge ( 0_int8 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int16 )) . eq . real ( huge ( 0_int16 )), huge ( 0_int16 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int32 )) . eq . real ( huge ( 0_int32 )), huge ( 0_int32 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int64 )) . eq . real ( huge ( 0_int64 )), huge ( 0_int64 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real32 )) . eq . real ( huge ( 0.0_real32 )), huge ( 0.0_real32 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real64 )) . eq . infinity , huge ( 0.0_real64 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real128 )). eq . infinity , huge ( 0.0_real128 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( 123 4.0_real64 ) . eq . 123 4.0_real64 , 123 4.0_real64 ) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( 123 4.0_real128 ) . eq . 123 4.0_real128 , 123 4.0_real128 ) call unit_check_done ( 'anyscalar_to_real' , msg = '' ) end subroutine test_anyscalar_to_real !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anything_to_bytes () integer :: i , j call unit_check_start ( 'anything_to_bytes' , msg = '' ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int8 )) . eq . transfer ( huge ( 0_int8 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int16 )) . eq . transfer ( huge ( 0_int16 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int32 )) . eq . transfer ( huge ( 0_int32 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int64 )) . eq . transfer ( huge ( 0_int64 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real32 )) . eq . transfer ( huge ( 0.0_real32 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real64 )) . eq . transfer ( huge ( 0.0_real64 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real128 )) . eq . transfer ( huge ( 0.0_real128 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( 'this is a string' ) . eq . transfer ( 'this is a string' , 'A' )) ) call unit_check ( 'anything_to_bytes' , any (& & anything_to_bytes ([ 'aaaaaaaaaa' , 'bbbbbbbbbb' ]) . eq . transfer ([ 'aaaaaaaaaa' , 'bbbbbbbbbb' ], 'A' )), 'check against transfer' ) call unit_check ( 'anything_to_bytes' , size ( anything_to_bytes ( 'this is a string' )) . eq . len ( 'this is a string' ), 'check byte count' ) i = size ( anything_to_bytes ([ 'aaaaaaaaaa' , 'bbbbbbbbbb' ])) j = len ( 'aaaaaaaaaabbbbbbbbbb' ) call unit_check ( 'anything_to_bytes' , i . eq . j , 'expected' , i , 'got' , j , 'check array byte count' ) call unit_check_done ( 'anything_to_bytes' , msg = '' ) end subroutine test_anything_to_bytes !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_empty !!use M_anything, only : empty, assignment(=) implicit none doubleprecision , allocatable :: d (:) integer , allocatable :: i (:) real , allocatable :: r (:) character ( len = :), allocatable :: c (:) integer , allocatable :: ints (:) character (:), allocatable :: strs (:) integer :: answer call unit_check_start ( 'empty' ) !  register an entry for specified name in database with status of zero (0) d = empty r = empty i = empty c = empty call unit_check ( 'empty' , size ( d ). eq . 0 , 'checking double' ) call unit_check ( 'empty' , size ( r ). eq . 0 , 'checking real' ) call unit_check ( 'empty' , size ( i ). eq . 0 , 'checking integer' ) call unit_check ( 'empty' , size ( c ). eq . 0 , 'checking character' ) ints = empty answer = 0 call check_ints ( answer , ints ) ints = [ 1 , 2 , 3 ] answer = 3 call check_ints ( answer , ints ) call unit_check ( 'empty' , all ( ints . eq .[ 1 , 2 , 3 ]), msg = 'normal allocation' ) ints = empty answer = 0 call check_ints ( answer , ints ) strs = empty answer = 0 call check_strs ( answer , strs ) strs = [ \"apple\" , \"orang\" , \"banan\" ] answer = 3 call check_strs ( answer , strs ) call unit_check ( 'empty' , all ( strs . eq .[ \"apple\" , \"orang\" , \"banan\" ]), msg = 'normal allocation' ) strs = empty answer = 0 call check_strs ( answer , strs ) call unit_check_done ( 'empty' ) end subroutine test_empty !----------------------------------------------------------------------------------------------------------------------------------- subroutine check_ints ( answer , ints ) integer , intent ( in ), allocatable :: ints (:) integer , intent ( in ) :: answer !  if mask test fails, change database status for specified entry to -1 and stop program, else continue if ( allocated ( ints )) then call unit_check ( 'empty' , size ( ints ). eq . answer , 'size is' , answer ) endif end subroutine check_ints !----------------------------------------------------------------------------------------------------------------------------------- subroutine check_strs ( answer , strs ) integer , intent ( in ) :: answer character ( len = :), allocatable , intent ( in ) :: strs (:) integer k if ( allocated ( strs ) ) then if ( unit_check_level . gt . 0 ) then print * , \"strs: val = \" , ( strs ( k ) // \" \" , k = 1 , size ( strs ) ) print * , \"      len_elem = \" , len ( strs ( 1 )) endif call unit_check ( 'empty' , size ( strs ). eq . answer , 'size is' , answer ) endif end subroutine check_strs !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== end program M_test_suite_M_anything","tags":"","url":"program/m_test_suite_m_anything.html"},{"title":"demo_anyinteger_to_string – M_anything","text":"Uses M_anything iso_fortran_env Source Code program demo_anyinteger_to_string use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use M_anything , only : itoc => anyinteger_to_string implicit none write ( * , * ) itoc ( huge ( 0_int8 )), '=> 127' write ( * , * ) itoc ( huge ( 0_int16 )), '=> 32767' write ( * , * ) itoc ( huge ( 0_int32 )), '=> 2147483647' write ( * , * ) itoc ( huge ( 0_int64 )), '=> 9223372036854775807' write ( * , * ) itoc ( - huge ( 0_int64 ) - 1 ) '=> -9223372036854775808' end program demo_anyinteger_to_string","tags":"","url":"program/demo_anyinteger_to_string.html"},{"title":"demo_anything_to_bytes – M_anything","text":"Uses M_anything Variables Type Attributes Name Initial integer :: i Source Code program demo_anything_to_bytes use M_anything , only : anything_to_bytes implicit none integer :: i write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ([( i * i , i = 1 , 10 )]) write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ([ 1 1.11 , 2 2.22 , 3 3.33 ]) write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ( 'This is a string' ) end program demo_anything_to_bytes","tags":"","url":"program/demo_anything_to_bytes.html"},{"title":"demo_anyscalar_to_int64 – M_anything","text":"Uses iso_fortran_env Functions function squarei (invalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Source Code program demo_anyscalar_to_int64 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( huge ( 0_int8 )), huge ( 0_int8 ) , & & '16129' write ( * , * ) squarei ( huge ( 0_int16 )), huge ( 0_int16 ) , & & '1073676289' write ( * , * ) squarei ( huge ( 0_int32 )), huge ( 0_int32 ) , & & '4611686014132420609' write ( * , * ) squarei ( huge ( 0_int64 )), huge ( 0_int64 ) , & & '85070591730234615847396907784232501249' contains ! function squarei ( invalue ) use M_anything , only : anyscalar_to_int64 class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: squarei invalue_local = anyscalar_to_int64 ( invalue ) squarei = invalue_local * invalue_local end function squarei ! end program demo_anyscalar_to_int64","tags":"","url":"program/demo_anyscalar_to_int64.html"},{"title":"demo_anyscalar_to_real – M_anything","text":"Uses iso_fortran_env Functions function squarei (invalue) result(dvalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value real Source Code program demo_anyscalar_to_real use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2_int8 ) write ( * , * ) squarei ( 2_int16 ) write ( * , * ) squarei ( 2_int32 ) write ( * , * ) squarei ( 2_int64 ) write ( * , * ) squarei ( 2.0_real32 ) write ( * , * ) squarei ( 2.0_real64 ) write ( * , * ) squarei ( 2.0_real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue invalue_local = anyscalar_to_real ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_real","tags":"","url":"program/demo_anyscalar_to_real.html"},{"title":"scalars – M_anything","text":"Uses M_anything iso_fortran_env THIS FUNCTION CAN TAKE AN INTEGER OR REAL OF ANY TYPE KNOWN TO ANYSCALAR_TO_REAL() AS AN ARGUMENT Variables Type Attributes Name Initial integer :: ios integer(kind=int64) :: large = huge(0_int64) integer(kind=int32) :: medium = huge(0_int32) real(kind=real128) :: rl = huge(0.0_real128) real(kind=real64) :: rm = huge(0.0_real64) real(kind=real32) :: rs = huge(0.0_real32) integer(kind=int16) :: small = huge(0_int16) integer(kind=int8) :: tiny = huge(0_int8) Functions function squarei (invalue) result(dvalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value real Source Code program scalars use M_anything , only : anyscalar_to_real use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none integer :: ios integer ( kind = int8 ) :: tiny = huge ( 0_int8 ) integer ( kind = int16 ) :: small = huge ( 0_int16 ) integer ( kind = int32 ) :: medium = huge ( 0_int32 ) integer ( kind = int64 ) :: large = huge ( 0_int64 ) real ( kind = real32 ) :: rs = huge ( 0.0_real32 ) real ( kind = real64 ) :: rm = huge ( 0.0_real64 ) real ( kind = real128 ) :: rl = huge ( 0.0_real128 ) 101 format ( a10 , \"|\" , i39 , \"|\" , i11 , \"|\" , i39 ) 102 format ( a10 , \"|\" , g0 , t55 , \"|\" , i11 , \"|\" , g0 ) write ( * , * ) 'First show the intrinsic variables of various KINDS we will be using' write ( * , * ) '  NAME   |VALUE                                  |KIND(VALUE)|10**RANGE(VALUE)' write ( * , 102 ) 'rs     ' , rs , kind ( rs ), 1 0.0_real32 ** range ( rs ) write ( * , 102 ) 'rm     ' , rm , kind ( rm ), 1 0.0_real64 ** range ( rm ) write ( * , 102 ) 'rl     ' , rl , kind ( rl ), 1 0.0_real128 ** range ( rl ) write ( * , 102 ) 'tiny   ' , tiny , kind ( tiny ) write ( * , 102 ) 'small  ' , small , kind ( small ) write ( * , 102 ) 'medium ' , medium , kind ( medium ) write ( * , 102 ) 'large  ' , large , kind ( large ) write ( * , * ) 'Test squarei with all INTEGER KINDs:' write ( * , * ) '(and given the following facts what is the expected output?)' write ( * , * ) 'FACTS:' write ( * , * ) '127 * 127 = 16129' write ( * , * ) '32767 * 32767 = 1073676289' write ( * , * ) '2147483647 * 2147483647 = 4611686014132420609' write ( * , * ) '9223372036854775807 * 9223372036854775807 = 85070591730234615847396907784232501249' write ( * , * ) '170141183460469231731687303715884105727 * 170141183460469231731687303715884105727 =& &28948022309329048855892746252171976962977213799489202546401021394546514198529' write ( * , * ) 'OUTPUT:' 202 format ( a , * ( g0 :, '; ' )) write ( * , 202 , iostat = ios ) 'SQUAREI()  :' , squarei ( tiny ), squarei ( small ), squarei ( medium ), squarei ( large ) write ( * , 202 , iostat = ios ) 'SQUAREI()  :' , squarei ( rs ), squarei ( rm ), squarei ( rl ) contains !! THIS FUNCTION CAN TAKE AN INTEGER OR REAL OF ANY TYPE KNOWN TO ANYSCALAR_TO_REAL() AS AN ARGUMENT function squarei ( invalue ) result ( dvalue ) ! square an integer value generically use M_anything , only : anyscalar_to_real implicit none class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue real , parameter :: biggest = sqrt ( real ( 0.0 , kind = real128 )) invalue_local = anyscalar_to_real ( invalue ) !if(invalue_local.gt.biggest)then !   write(*,*)'ERROR:*squarei* input value to big=',invalue_local !endif dvalue = invalue_local * invalue_local end function squarei end program scalars","tags":"","url":"program/scalars.html"},{"title":"demo_anyscalar_to_string.f90 – M_anything","text":"Source Code program demo_anyscalar_to_string use M_anything , only : anyscalar_to_string implicit none character ( len = :), allocatable :: pr character ( len = :), allocatable :: frmt integer :: biggest pr = anyscalar_to_string ( 'HUGE(3f) integers' , huge ( 0 ),& & 'and real' , huge ( 0.0 ), 'and double' , huge ( 0.0d0 )) write ( * , '(a)' ) pr pr = anyscalar_to_string ( 'real            :' , huge ( 0.0 ), 0.0 , 1234 5.6789 , tiny ( 0.0 ) ) write ( * , '(a)' ) pr pr = anyscalar_to_string ( 'doubleprecision :' , huge ( 0.0d0 ), 0.0d0 , 1234 5.6789d0 , tiny ( 0.0d0 ) ) write ( * , '(a)' ) pr pr = anyscalar_to_string ( 'complex         :' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) write ( * , '(a)' ) pr ! create a format on the fly biggest = huge ( 0 ) frmt = anyscalar_to_string ( '(*(i' , int ( log10 ( real ( biggest ))), ':,1x))' , sep = '' ) write ( * , * ) 'format=' , frmt ! although it will often work, using anyscalar_to_string(3f) ! in an I/O statement is not recommended ! because if an error occurs anyscalar_to_string(3f) will try ! to write while part of an I/O statement ! which not all compilers can handle and is currently non-standard write ( * , * ) anyscalar_to_string ( 'program will now stop' ) end program demo_anyscalar_to_string","tags":"","url":"sourcefile/demo_anyscalar_to_string.f90.html"},{"title":"demo_bytes_to_anything.f90 – M_anything","text":"Source Code program demo_bytes_to_anything use , intrinsic :: ISO_FORTRAN_ENV , only : & CSZ => CHARACTER_STORAGE_SIZE , & stderr => error_unit use :: M_anything , only : bytes_to_anything , anything_to_bytes implicit none character ( len = 1 ), allocatable :: chars (:) character ( len = :), allocatable :: line character ( len = :), allocatable :: lines (:) integer :: ints ( 10 ) integer :: i , int integer , allocatable :: somesize (:) call header ( 'integer array to bytes' ) chars = anything_to_bytes ([( i * i , i = 1 , size ( ints ))]) write ( * , '(/,4(1x,z2.2))' ) chars call bytes_to_anything ( chars , ints ) write ( * , * ) 'and bytes back to integer array' write ( * , '(/,*(g0,1x))' ) ints call header ( 'integer scalar to bytes' ) chars = anything_to_bytes ( 1234 ) write ( * , '(/,\"CHARS=\",*(1x,z2.2))' ) chars call bytes_to_anything ( chars , int ) write ( * , * ) 'and bytes back to integer scalar' write ( * , '(/,\"INT=\",*(g0,1x))' ) int call header ( 'a string' ) chars = anything_to_bytes ( 'this is a string' ) write ( * , '(/,\"CHARS=\",*(1x,z2.2))' ) chars write ( * , '(/,\"CHARS=\",*(g0,1x))' ) chars ! string must be long enough to hold chars line = repeat ( ' ' , size ( chars )) call bytes_to_anything ( chars , line ) write ( * , '(/,\"LINE=\",*(g0,1x))' ) line call header (& 'a string array (have to know length or size you wish to return to)' ) chars = anything_to_bytes ([ character ( len = 4 ) :: 'a' , 'bb' , 'ccc' ]) write ( * , '(/,\"CHARS=\",*(1x,z2.2))' ) chars write ( * , '(/,\"CHARS=\",*(g0,1x))' ) chars ! string must be long enough to hold chars, and have enough elements ! can just return as a scalar string if unknown length lines = [ repeat ( ' ' , size ( chars ))] ! of for that matter just work with the chars(1) array, ! but assuming know length in this case lines = [( repeat ( '#' , 4 ), i = 1 , 3 )] call bytes_to_anything ( chars , lines ) write ( * , '(/,\"LINES=\",*(\"[\",g0,\"]\",1x:))' ) lines call header ( 'calculating size to allocate for non-string types' ) ! make sure array is of sufficient size to hold results chars = anything_to_bytes ([ 11 , 22 , 33 , 44 ]) write ( * , '(/,\"CHARS=\",*(1x,z2.2))' ) chars allocate ( somesize ( size ( chars ) / ( storage_size ( 0 ) / CSZ ))) call bytes_to_anything ( chars , somesize ) write ( * , '(/,\"SOMESIZE=\",*(\"[\",g0,\"]\",1x:))' ) somesize contains subroutine header ( line ) character ( len =* ), intent ( in ) :: line write ( * , '(*(a))' ) '#' , repeat ( '=' , len ( line ) + 2 ), '#' write ( * , '(\"|\",1x,a,1x,\"|\")' ) line write ( * , '(*(a))' ) '#' , repeat ( '=' , len ( line ) + 2 ), '#' end subroutine header end program demo_bytes_to_anything","tags":"","url":"sourcefile/demo_bytes_to_anything.f90.html"},{"title":"demo_anyscalar_to_double.f90 – M_anything","text":"Source Code program demo_anyscalar_to_double use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2_int8 ) write ( * , * ) squarei ( 2_int16 ) write ( * , * ) squarei ( 2_int32 ) write ( * , * ) squarei ( 2_int64 ) write ( * , * ) squarei ( 2.0_real32 ) write ( * , * ) squarei ( 2.0_real64 ) write ( * , * ) squarei ( 2.0_real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_double","tags":"","url":"sourcefile/demo_anyscalar_to_double.f90.html"},{"title":"demo_get_type.f90 – M_anything","text":"Source Code program demo_get_type use M_anything , only : get_type implicit none integer :: i write ( * , * ) get_type ([( i * i , i = 1 , 10 )]) write ( * , * ) get_type ([ 1 1.11 , 2 2.22 , 3 3.33 ]) write ( * , * ) get_type ( 'This is a string' ) write ( * , * ) get_type ( 3 0.0d0 ) end program demo_get_type","tags":"","url":"sourcefile/demo_get_type.f90.html"},{"title":"demo_empty.f90 – M_anything","text":"Source Code program demo_empty_ use M_anything , only : empty , assignment ( = ) integer , allocatable :: ints (:) character (:), allocatable :: strs (:) real , allocatable :: reals (:) ints = empty write ( * , * ) size ( ints ) write ( * , * ) 'give them some size ...' reals = [ 1.0 , 2.0 , 3.0 ] ints = [ 1 , 2 , 3 ] strs = [ character ( len = 10 ) :: \"one\" , \"two\" , \"three\" , \"four\" ] write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) ints = empty reals = empty strs = empty write ( * , * ) 'back to empty ...' write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) end program demo_empty_","tags":"","url":"sourcefile/demo_empty.f90.html"},{"title":"demo_M_anything.f90 – M_anything","text":"Source Code program demo_M_anything use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squareall ( 2_int8 ) write ( * , * ) squareall ( 2_int16 ) write ( * , * ) squareall ( 2_int32 ) write ( * , * ) squareall ( 2_int64 ) write ( * , * ) squareall ( 2.0_real32 ) write ( * , * ) squareall ( 2.0_real64 ) write ( * , * ) squareall ( 2.0_real128 ) contains function squareall ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squareall end program demo_M_anything","tags":"","url":"sourcefile/demo_m_anything.f90.html"},{"title":"demo_anyscalar_to_real128.f90 – M_anything","text":"Source Code program demo_anyscalar_to_real128 use , intrinsic :: iso_fortran_env , only : & & sp => real32 , dp => real64 , qp => real128 , & & i8 => int8 , i16 => int16 , i32 => int32 , i64 => int64 implicit none ! call function with various intrinsic numeric types write ( * , * ) minall ( 2_i8 , 3_i16 , 4_i32 , 5_i64 , 6.0_sp , 7.0_dp , 8.0_qp ) write ( * , * ) minall ( 2.0_qp , 2.0_dp , 2.0_sp , 2_i8 , 2_i16 , 2_i32 , 2_i64 ) write ( * , * ) min ( 2.0_qp , 2.0_dp ) write ( * , * ) min ( 2.0_qp , 2.0_dp , 2.0_sp , 2_i8 , 2_i16 , 2_i32 , 2_i64 ) contains function minall ( a , b , c , d , e , f , g ) result ( value ) use M_anything , only : x => anyscalar_to_real128 class ( * ), intent ( in ) :: a , b , c , d , e , f , g real ( kind = qp ) :: value value = min ( x ( a ), x ( b ), x ( c ), x ( d ), x ( e ), x ( f ), x ( g ) ) end function minall end program demo_anyscalar_to_real128","tags":"","url":"sourcefile/demo_anyscalar_to_real128.f90.html"},{"title":"test_suite_M_anything.f90 – M_anything","text":"Source Code program M_test_suite_M_anything use , intrinsic :: ISO_FORTRAN_ENV , only : INT8 , INT16 , INT32 , INT64 !  1           2           4           8 use , intrinsic :: ISO_FORTRAN_ENV , only : REAL32 , REAL64 , REAL128 !  4           8          10 use M_anything , only : anyinteger_to_string , anyscalar_to_int64 use M_anything , only : anyscalar_to_real , anyscalar_to_double , anyscalar_to_real128 use M_anything , only : anything_to_bytes , bytes_to_anything use M_anything , only : empty , assignment ( = ) use M_framework__msg use M_framework__verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_framework__verify , only : unit_check_stop use M_framework__verify , only : unit_check_level implicit none unit_check_level = 0 !! setup call test_anyscalar_to_int64 () call test_anyinteger_to_string () call test_anyscalar_to_real () call test_anyscalar_to_double () call test_anything_to_bytes () call test_empty () !!teardown call unit_check_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_int64 () call unit_check_start ( 'anyscalar_to_int64' , msg = '' ) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int8 )) . eq . 127_int64 , huge ( 0_int8 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int16 )). eq . 32767_int64 , huge ( 0_int16 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int32 )). eq . 2147483647_int64 , huge ( 0_int32 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int64 )). eq . 9223372036854775807_int64 , huge ( 0_int64 )) call unit_check_done ( 'anyscalar_to_int64' , msg = '' ) end subroutine test_anyscalar_to_int64 !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyinteger_to_string () call unit_check_start ( 'anyinteger_to_string' , msg = '' ) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int8 )) . eq . '127' , huge ( 0_int8 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int16 )). eq . '32767' , huge ( 0_int16 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int32 )). eq . '2147483647' , huge ( 0_int32 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int64 )). eq . '9223372036854775807' , huge ( 0_int64 )) call unit_check_done ( 'anyinteger_to_string' , msg = '' ) end subroutine test_anyinteger_to_string !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_double () real :: infinity !!character(len=*),parameter :: line='infinity' character ( len = 8 ) :: line = 'infinity' read ( line , * ) infinity call unit_check_start ( 'anyscalar_to_double' , msg = '' ) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int8 )) . eq . huge ( 0_int8 ), huge ( 0_int8 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int16 )) . eq . huge ( 0_int16 ), huge ( 0_int16 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int32 )) . eq . huge ( 0_int32 ), huge ( 0_int32 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int64 )) . eq . huge ( 0_int64 ), huge ( 0_int64 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real32 )) . eq . huge ( 0.0_real32 ), huge ( 0.0_real32 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real64 )) . eq . huge ( 0.0_real64 ), huge ( 0.0_real64 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real128 )) . eq . infinity , huge ( 0.0_real128 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( 123 4.0_real128 ) . eq . 123 4.0_real128 , 123 4.0_real128 ) call unit_check_done ( 'anyscalar_to_double' , msg = '' ) end subroutine test_anyscalar_to_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_real () real :: infinity !!character(len=*),parameter :: line='infinity' character ( len = 8 ) :: line = 'infinity' read ( line , * ) infinity call unit_check_start ( 'anyscalar_to_real' , msg = '' ) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int8 )) . eq . real ( huge ( 0_int8 )), huge ( 0_int8 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int16 )) . eq . real ( huge ( 0_int16 )), huge ( 0_int16 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int32 )) . eq . real ( huge ( 0_int32 )), huge ( 0_int32 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int64 )) . eq . real ( huge ( 0_int64 )), huge ( 0_int64 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real32 )) . eq . real ( huge ( 0.0_real32 )), huge ( 0.0_real32 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real64 )) . eq . infinity , huge ( 0.0_real64 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real128 )). eq . infinity , huge ( 0.0_real128 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( 123 4.0_real64 ) . eq . 123 4.0_real64 , 123 4.0_real64 ) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( 123 4.0_real128 ) . eq . 123 4.0_real128 , 123 4.0_real128 ) call unit_check_done ( 'anyscalar_to_real' , msg = '' ) end subroutine test_anyscalar_to_real !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anything_to_bytes () integer :: i , j call unit_check_start ( 'anything_to_bytes' , msg = '' ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int8 )) . eq . transfer ( huge ( 0_int8 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int16 )) . eq . transfer ( huge ( 0_int16 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int32 )) . eq . transfer ( huge ( 0_int32 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int64 )) . eq . transfer ( huge ( 0_int64 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real32 )) . eq . transfer ( huge ( 0.0_real32 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real64 )) . eq . transfer ( huge ( 0.0_real64 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real128 )) . eq . transfer ( huge ( 0.0_real128 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( 'this is a string' ) . eq . transfer ( 'this is a string' , 'A' )) ) call unit_check ( 'anything_to_bytes' , any (& & anything_to_bytes ([ 'aaaaaaaaaa' , 'bbbbbbbbbb' ]) . eq . transfer ([ 'aaaaaaaaaa' , 'bbbbbbbbbb' ], 'A' )), 'check against transfer' ) call unit_check ( 'anything_to_bytes' , size ( anything_to_bytes ( 'this is a string' )) . eq . len ( 'this is a string' ), 'check byte count' ) i = size ( anything_to_bytes ([ 'aaaaaaaaaa' , 'bbbbbbbbbb' ])) j = len ( 'aaaaaaaaaabbbbbbbbbb' ) call unit_check ( 'anything_to_bytes' , i . eq . j , 'expected' , i , 'got' , j , 'check array byte count' ) call unit_check_done ( 'anything_to_bytes' , msg = '' ) end subroutine test_anything_to_bytes !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_empty !!use M_anything, only : empty, assignment(=) implicit none doubleprecision , allocatable :: d (:) integer , allocatable :: i (:) real , allocatable :: r (:) character ( len = :), allocatable :: c (:) integer , allocatable :: ints (:) character (:), allocatable :: strs (:) integer :: answer call unit_check_start ( 'empty' ) !  register an entry for specified name in database with status of zero (0) d = empty r = empty i = empty c = empty call unit_check ( 'empty' , size ( d ). eq . 0 , 'checking double' ) call unit_check ( 'empty' , size ( r ). eq . 0 , 'checking real' ) call unit_check ( 'empty' , size ( i ). eq . 0 , 'checking integer' ) call unit_check ( 'empty' , size ( c ). eq . 0 , 'checking character' ) ints = empty answer = 0 call check_ints ( answer , ints ) ints = [ 1 , 2 , 3 ] answer = 3 call check_ints ( answer , ints ) call unit_check ( 'empty' , all ( ints . eq .[ 1 , 2 , 3 ]), msg = 'normal allocation' ) ints = empty answer = 0 call check_ints ( answer , ints ) strs = empty answer = 0 call check_strs ( answer , strs ) strs = [ \"apple\" , \"orang\" , \"banan\" ] answer = 3 call check_strs ( answer , strs ) call unit_check ( 'empty' , all ( strs . eq .[ \"apple\" , \"orang\" , \"banan\" ]), msg = 'normal allocation' ) strs = empty answer = 0 call check_strs ( answer , strs ) call unit_check_done ( 'empty' ) end subroutine test_empty !----------------------------------------------------------------------------------------------------------------------------------- subroutine check_ints ( answer , ints ) integer , intent ( in ), allocatable :: ints (:) integer , intent ( in ) :: answer !  if mask test fails, change database status for specified entry to -1 and stop program, else continue if ( allocated ( ints )) then call unit_check ( 'empty' , size ( ints ). eq . answer , 'size is' , answer ) endif end subroutine check_ints !----------------------------------------------------------------------------------------------------------------------------------- subroutine check_strs ( answer , strs ) integer , intent ( in ) :: answer character ( len = :), allocatable , intent ( in ) :: strs (:) integer k if ( allocated ( strs ) ) then if ( unit_check_level . gt . 0 ) then print * , \"strs: val = \" , ( strs ( k ) // \" \" , k = 1 , size ( strs ) ) print * , \"      len_elem = \" , len ( strs ( 1 )) endif call unit_check ( 'empty' , size ( strs ). eq . answer , 'size is' , answer ) endif end subroutine check_strs !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== end program M_test_suite_M_anything","tags":"","url":"sourcefile/test_suite_m_anything.f90.html"},{"title":"demo_anyinteger_to_string.f90 – M_anything","text":"Source Code program demo_anyinteger_to_string use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use M_anything , only : itoc => anyinteger_to_string implicit none write ( * , * ) itoc ( huge ( 0_int8 )), '=> 127' write ( * , * ) itoc ( huge ( 0_int16 )), '=> 32767' write ( * , * ) itoc ( huge ( 0_int32 )), '=> 2147483647' write ( * , * ) itoc ( huge ( 0_int64 )), '=> 9223372036854775807' write ( * , * ) itoc ( - huge ( 0_int64 ) - 1 ) '=> -9223372036854775808' end program demo_anyinteger_to_string","tags":"","url":"sourcefile/demo_anyinteger_to_string.f90.html"},{"title":"M_anything.F90 – M_anything","text":"Source Code !=================================================================================================================================== ! This module and the example function squarei() that uses it shows how you ! can use polymorphism to allow arguments of different types generically by casting !=================================================================================================================================== #ifdef __NVCOMPILER #undef HAS_REAL128 #else #define HAS_REAL128 #endif #ifdef Linux_ifx #ifndef __INTEL_LLVM_COMPILER #define __INTEL_LLVM_COMPILER  IFX #endif #endif !=================================================================================================================================== !> !!##NAME !!    M_anything(3fm) - [M_anything::INTRO] procedures that use polymorphism to allow arguments of different types generically !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!      use M_anything,only : anyscalar_to_string !!      use M_anything,only : anyscalar_to_int64 !!      use M_anything,only : anyscalar_to_real !!      use M_anything,only : anyscalar_to_real128 !!      use M_anything,only : anyscalar_to_double !!      use M_anything,only : anything_to_bytes !!      use M_anything,only : anyinteger_to_string !!      use M_anything,only : get_type !!      use M_anything,only : bytes_to_anything !!      use M_anything,only : empty, assignment(=) !! !!##DESCRIPTION !!       anyscalar_to_string     convert intrinsic type to string !!       anyscalar_to_int64      convert integer or real of any kind to 64-bit integer !!       anyscalar_to_real       convert integer or real of any kind to real !!       anyscalar_to_real128    convert integer or real of any kind to real128 !!       anyscalar_to_double     convert integer or real of any kind to doubleprecision !!       anything_to_bytes       convert anything to bytes !!       anyinteger_to_string    convert integer to string !!       get_type                return array of strings containing type names of arguments !!       empty                   create an empty array !! !!##EXAMPLE !! !! !! At the cost of casting to a different type these functions can !! (among other uses such as in linked lists) allow for an alternative !! to duplicating code using generic procedure methods. For example, !! the following SQUAREALL function can take many input types and return a !! DOUBLEPRECISION value (it is a trivial example for demonstration purposes, !! and does not check for overflow, etc.).: !! !!   Sample program !! !!     program demo_M_anything !!     use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!     use, intrinsic :: iso_fortran_env, only : real32, real64, real128 !!     implicit none !!        ! call same function with many scalar input types !!        write(*,*)squareall(2_int8) !!        write(*,*)squareall(2_int16) !!        write(*,*)squareall(2_int32) !!        write(*,*)squareall(2_int64) !!        write(*,*)squareall(2.0_real32) !!        write(*,*)squareall(2.0_real64) !!        write(*,*)squareall(2.0_real128) !!     contains !! !!     function squareall(invalue) result (dvalue) !!     use M_anything, only : anyscalar_to_double !!     class(*),intent(in)  :: invalue !!     doubleprecision      :: invalue_local !!     doubleprecision      :: dvalue !!        invalue_local=anyscalar_to_double(invalue) !!        dvalue=invalue_local*invalue_local !!     end function squareall !! !!     end program demo_M_anything !! !!   Results: !! !!       4.00000000000000 !!       4.00000000000000 !!       4.00000000000000 !!       4.00000000000000 !!       4.00000000000000 !!       4.00000000000000 !!       4.00000000000000 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT module M_anything use , intrinsic :: ISO_FORTRAN_ENV , only : INT8 , INT16 , INT32 , INT64 !  1           2           4           8 use , intrinsic :: ISO_FORTRAN_ENV , only : REAL32 , REAL64 , REAL128 !  4           8          10 use , intrinsic :: ISO_FORTRAN_ENV , only : CSZ => CHARACTER_STORAGE_SIZE use , intrinsic :: iso_fortran_env , only : stderr => error_unit !! ,input_unit,output_unit implicit none private integer , parameter :: dp = kind ( 0.0d0 ) public anyscalar_to_string ! convert integer parameter of any kind to string public anyscalar_to_int64 ! convert integer parameter of any kind to 64-bit integer public anyscalar_to_real ! convert integer or real parameter of any kind to real #ifdef HAS_REAL128 public anyscalar_to_real128 ! convert integer or real parameter of any kind to real128 #endif public anyscalar_to_double ! convert integer or real parameter of any kind to doubleprecision public anything_to_bytes public get_type public bytes_to_anything public anyinteger_to_string ! convert integer parameter of any kind to string !!public setany interface anything_to_bytes module procedure anything_to_bytes_arr module procedure anything_to_bytes_scalar end interface anything_to_bytes interface bytes_to_anything module procedure bytes_to_anything_arr module procedure bytes_to_anything_scalar end interface bytes_to_anything interface get_type module procedure get_type_arr module procedure get_type_scalar end interface get_type !=================================================================================================================================== !   Because there is no builtin \"empty array\" object, I've tried to mimic !   it with some user-defined type (just for fun).  -- spectrum ! ! So, if there is a language support, it might be not too difficult ! to think of a common \"empty array\" thing (though not sure if it is ! sufficiently useful). ! public empty , assignment ( = ) type Empty_t endtype type ( Empty_t ) empty !! singleton interface assignment ( = ) module procedure & & ints_empty_ , & & reals_empty_ , & & doubles_empty_ , & & strings_empty_ endinterface contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    empty(3f) - [M_anything] set an allocatable array to zero !!    (LICENSE:MIT) !!##SYNOPSIS !! !!    use M_anything, only : empty, assignment(=) !!##DESCRIPTION !!    A convenience routine that sets an array to an empty set. !!##EXAMPLE !! !! !!   Sample program: !! !!    program demo_empty_ !!    use M_anything, only : empty, assignment(=) !!    integer, allocatable      :: ints(:) !!    character(:), allocatable :: strs(:) !!    real, allocatable      :: reals(:) !!       ints=empty !!       write(*,*)size(ints) !! !!       write(*,*)'give them some size ...' !!       reals = [1.0,2.0,3.0] !!       ints = [1,2,3] !!       strs = [character(len=10) :: \"one\",\"two\",\"three\",\"four\"] !!       write(*,*)size(ints) !!       write(*,*)size(reals) !!       write(*,*)size(strs) !! !!       ints=empty !!       reals=empty !!       strs=empty !!       write(*,*)'back to empty ...' !!       write(*,*)size(ints) !!       write(*,*)size(reals) !!       write(*,*)size(strs) !! !!    end program demo_empty_ !! !!   Expected output: !! !!    >             0 !!    >   give them some size ... !!    >             3 !!    >             3 !!    >             4 !!    >   back to empty ... !!    >             0 !!    >             0 !!    >             0 !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT subroutine ints_empty_ ( x , emp ) integer , allocatable , intent ( inout ) :: x (:) type ( Empty_t ), intent ( in ) :: emp if ( allocated ( x ) ) deallocate ( x ) allocate ( x ( 0 ) ) end subroutine ints_empty_ subroutine doubles_empty_ ( x , emp ) doubleprecision , allocatable , intent ( inout ) :: x (:) type ( Empty_t ), intent ( in ) :: emp if ( allocated ( x ) ) deallocate ( x ) allocate ( x ( 0 ) ) end subroutine doubles_empty_ subroutine reals_empty_ ( x , emp ) real , allocatable , intent ( inout ) :: x (:) type ( Empty_t ), intent ( in ) :: emp if ( allocated ( x ) ) deallocate ( x ) allocate ( x ( 0 ) ) end subroutine reals_empty_ subroutine strings_empty_ ( x , emp ) character (:), allocatable , intent ( inout ) :: x (:) type ( Empty_t ), intent ( in ) :: emp if ( allocated ( x ) ) deallocate ( x ) allocate ( character ( 0 ) :: x ( 0 ) ) end subroutine strings_empty_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    bytes_to_anything(3f) - [M_anything] convert bytes(character)len=1):: array(:)) to standard types !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!   subroutine bytes_to_anything(chars,anything) !! !!    character(len=1),allocatable :: chars(:) !!    class(*) :: anything !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different !!    types. It is used to create other procedures that can take many !!    argument types as input options and convert them to a single type !!    to simplify storing arbitrary data, to simplify generating data !!    hashes, ... !! !!##OPTIONS !!    CHARS     The input value is an array of bytes (character(len=1)). !! !!##RETURN !!    ANYTHING  May be of KIND INTEGER(kind=int8), INTEGER(kind=int16), !!              INTEGER(kind=int32), INTEGER(kind=int64), !!              REAL(kind=real32, REAL(kind=real64), !!              REAL(kind=real128), complex, or CHARACTER(len=*) !! !!##EXAMPLE !! !! !!   Sample program !! !!       program demo_bytes_to_anything !!       use, intrinsic :: ISO_FORTRAN_ENV, only: & !!            CSZ => CHARACTER_STORAGE_SIZE & !!            stderr => error_unit !!       use :: M_anything, only : bytes_to_anything, anything_to_bytes !!       implicit none !!       character(len=1), allocatable :: chars(:) !!       character(len=:), allocatable :: line !!       character(len=:), allocatable :: lines(:) !!       integer :: ints(10) !!       integer :: i, int !!       integer,allocatable :: somesize(:) !! !!       call header('integer array to bytes') !!       chars = anything_to_bytes([(i*i, i=1, size(ints))]) !!       write (*, '(/,4(1x,z2.2))') chars !!       call bytes_to_anything(chars, ints) !!       write(*,*)'and bytes back to integer array' !!       write (*, '(/,*(g0,1x))') ints !! !!       call header('integer scalar to bytes') !!       chars = anything_to_bytes(1234) !!       write (*, '(/,\"CHARS=\",*(1x,z2.2))') chars !!       call bytes_to_anything(chars, int) !!       write(*,*)'and bytes back to integer scalar' !!       write (*, '(/,\"INT=\",*(g0,1x))') int !! !!       call header('a string') !!       chars = anything_to_bytes('this is a string') !!       write (*, '(/,\"CHARS=\",*(1x,z2.2))') chars !!       write (*, '(/,\"CHARS=\",*(g0,1x))') chars !!       ! string must be long enough to hold chars !!       line=repeat(' ',size(chars)) !!       call bytes_to_anything(chars, line) !!       write (*, '(/,\"LINE=\",*(g0,1x))') line !! !!       call header(& !!       'a string array (have to know length or size you wish to return to)') !!       chars = anything_to_bytes([character(len=4) :: 'a', 'bb', 'ccc' ]) !!       write (*, '(/,\"CHARS=\",*(1x,z2.2))') chars !!       write (*, '(/,\"CHARS=\",*(g0,1x))') chars !!       ! string must be long enough to hold chars, and have enough elements !!       ! can just return as a scalar string if unknown length !!       lines=[repeat(' ',size(chars))] !!       ! of for that matter just work with the chars(1) array, !!       ! but assuming know length in this case !!       lines=[(repeat('#',4),i=1,3)] !!       call bytes_to_anything(chars, lines) !!       write (*, '(/,\"LINES=\",*(\"[\",g0,\"]\",1x:))') lines !! !!       call header('calculating size to allocate for non-string types') !!       ! make sure array is of sufficient size to hold results !!       chars = anything_to_bytes([11,22,33,44]) !!       write (*, '(/,\"CHARS=\",*(1x,z2.2))') chars !!       allocate(somesize(size(chars)/(storage_size(0)/CSZ))) !!       call bytes_to_anything(chars, somesize) !!       write (*, '(/,\"SOMESIZE=\",*(\"[\",g0,\"]\",1x:))') somesize !!       contains !!       subroutine header(line) !!       character(len=*),intent(in) :: line !!       write(*,'(*(a))')'#',repeat('=',len(line)+2),'#' !!       write(*,'(\"|\",1x,a,1x,\"|\")') line !!       write(*,'(*(a))')'#',repeat('=',len(line)+2),'#' !!       end subroutine header !!       end program demo_bytes_to_anything !! !! Results: !! !!     > #========================# !!     > | integer array to bytes | !!     > #========================# !!     > !!     >  01 00 00 00 !!     >  04 00 00 00 !!     >  09 00 00 00 !!     >  10 00 00 00 !!     >  19 00 00 00 !!     >  24 00 00 00 !!     >  31 00 00 00 !!     >  40 00 00 00 !!     >  51 00 00 00 !!     >  64 00 00 00 !!     >  and bytes back to integer array !!     > !!     > 1 4 9 16 25 36 49 64 81 100 !!     > #=========================# !!     > | integer scalar to bytes | !!     > #=========================# !!     > !!     > CHARS= D2 04 00 00 !!     >  and bytes back to integer scalar !!     > !!     > INT=1234 !!     > #==========# !!     > | a string | !!     > #==========# !!     > !!     > CHARS= 74 68 69 73 20 69 73 20 61 20 73 74 72 69 6E 67 !!     > !!     > CHARS=t h i s   i s   a   s t r i n g !!     > !!     > LINE=this is a string !!     > #====================================================================# !!     > | a string array (have to know length or size you wish to return to) | !!     > #====================================================================# !!     > !!     > CHARS= 61 20 20 20 62 62 20 20 63 63 63 20 !!     > !!     > CHARS=a       b b     c c c !!     > !!     > LINES=[a   ] [bb  ] [ccc ] !!     > #===================================================# !!     > | calculating size to allocate for non-string types | !!     > #===================================================# !!     > !!     > CHARS= 0B 00 00 00 16 00 00 00 21 00 00 00 2C 00 00 00 !!     > !!     > SOMESIZE=[11] [22] [33] [44] !! !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    MIT subroutine bytes_to_anything_arr ( chars , anything ) character ( len = 1 ), intent ( in ) :: chars (:) class ( * ), intent ( out ) :: anything (:) select type ( anything ) type is ( character ( len =* )); anything = transfer ( chars , anything ) type is ( complex ); anything = transfer ( chars , anything ) type is ( complex ( kind = dp )); anything = transfer ( chars , anything ) type is ( integer ( kind = int8 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int16 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int32 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int64 )); anything = transfer ( chars , anything ) type is ( real ( kind = real32 )); anything = transfer ( chars , anything ) type is ( real ( kind = real64 )); anything = transfer ( chars , anything ) type is ( real ( kind = real128 )); anything = transfer ( chars , anything ) type is ( logical ); anything = transfer ( chars , anything ) class default !anything=transfer(chars,anything) stop 'crud. bytes_to_anything(1) does not know about this type' end select end subroutine bytes_to_anything_arr subroutine bytes_to_anything_scalar ( chars , anything ) character ( len = 1 ), intent ( in ) :: chars (:) class ( * ), intent ( out ) :: anything select type ( anything ) ! caller must ensure string passed in is long enough for results type is ( character ( len =* )); anything = transfer ( chars , repeat ( 'x' , size ( chars ))) if ( len ( anything ). lt . size ( chars )) then write ( stderr , * ) '<ERROR> *bytes_to_anything* crud. string not long enough to hold results. cannot put' , size ( chars ),& 'bytes in string of length' , len ( anything ) stop endif type is ( complex ); anything = transfer ( chars , anything ) type is ( complex ( kind = dp )); anything = transfer ( chars , anything ) type is ( integer ( kind = int8 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int16 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int32 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int64 )); anything = transfer ( chars , anything ) type is ( real ( kind = real32 )); anything = transfer ( chars , anything ) type is ( real ( kind = real64 )); anything = transfer ( chars , anything ) type is ( real ( kind = real128 )); anything = transfer ( chars , anything ) type is ( logical ); anything = transfer ( chars , anything ) class default !anything=transfer(chars,anything) stop 'crud. bytes_to_anything(1) does not know about this type' end select end subroutine bytes_to_anything_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    anything_to_bytes(3f) - [M_anything] convert standard types to bytes (character(len=1):: array(:)) !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    function anything_to_bytes(anything) result(chars) !! !!     class(*),intent(in)  :: anything !!             or !!     class(*),intent(in)  :: anything(:) !! !!     character(len=1),allocatable :: chars(:) !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different !!    types. It is used to create other procedures that can take many !!    argument types as input options and convert them to a single type !!    to simplify storing arbitrary data, to simplify generating data !!    hashes, ... !! !!##OPTIONS !! !!    VALUEIN  input array or scalar to convert to type CHARACTER(LEN=1). !!             May be of KIND INTEGER(kind=int8), INTEGER(kind=int16), !!             INTEGER(kind=int32), INTEGER(kind=int64), !!             REAL(kind=real32, REAL(kind=real64), !!             REAL(kind=real128), complex, or CHARACTER(len=*) !!##RETURN !! !!    CHARS    The returned value is an array of bytes (character(len=1)). !! !!##EXAMPLE !! !! !!   Sample program !! !!    program demo_anything_to_bytes !!    use M_anything,      only : anything_to_bytes !!    implicit none !!    integer :: i !!       write(*,'(/,4(1x,z2.2))')anything_to_bytes([(i*i,i=1,10)]) !!       write(*,'(/,4(1x,z2.2))')anything_to_bytes([11.11,22.22,33.33]) !!       write(*,'(/,4(1x,z2.2))')anything_to_bytes('This is a string') !!    end program demo_anything_to_bytes !! !!   Expected output !! !!        01 00 00 00 !!        04 00 00 00 !!        09 00 00 00 !!        10 00 00 00 !!        19 00 00 00 !!        24 00 00 00 !!        31 00 00 00 !!        40 00 00 00 !!        51 00 00 00 !!        64 00 00 00 !! !!        8F C2 31 41 !!        8F C2 B1 41 !!        EC 51 05 42 !! !!        54 68 69 73 !!        20 69 73 20 !!        61 20 73 74 !!        72 69 6E 67 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    MIT function anything_to_bytes_arr ( anything ) result ( chars ) ! this seems like it should just be a call to transfer(), but seems to need the select type on at least several compilers ! ident_1=\"@(#) M_anything anything_to_bytes_arr(3fp) any vector of intrinsics to bytes (an array of CHARACTER(LEN=1) variables)\" class ( * ), intent ( in ) :: anything (:) character ( len = 1 ), allocatable :: chars (:) if ( allocated ( chars )) deallocate ( chars ) allocate ( chars ( storage_size ( anything ) / CSZ * size ( anything ) ) ) select type ( anything ) type is ( character ( len =* )); chars = transfer ( anything , chars ) type is ( complex ); chars = transfer ( anything , chars ) type is ( complex ( kind = dp )); chars = transfer ( anything , chars ) type is ( integer ( kind = int8 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int16 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int32 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int64 )); chars = transfer ( anything , chars ) type is ( real ( kind = real32 )); chars = transfer ( anything , chars ) type is ( real ( kind = real64 )); chars = transfer ( anything , chars ) #ifdef HAS_REAL128 type is ( real ( kind = real128 )); chars = transfer ( anything , chars ) #endif type is ( logical ); chars = transfer ( anything , chars ) class default !stop 'crud. anything_to_bytes_arr(1) does not know about this type' chars = transfer ( anything , chars ) ! should work for everything, does not with some compilers end select end function anything_to_bytes_arr !----------------------------------------------------------------------------------------------------------------------------------- function anything_to_bytes_scalar ( anything ) result ( chars ) ! ident_2=\"@(#) M_anything anything_to_bytes_scalar(3fp) anything to bytes (an array of CHARACTER(LEN=1) variables)\" class ( * ), intent ( in ) :: anything character ( len = 1 ), allocatable :: chars (:) if ( allocated ( chars )) deallocate ( chars ) allocate ( chars ( storage_size ( anything ) / CSZ ) ) select type ( anything ) type is ( character ( len =* )); chars = transfer ( anything , chars ) type is ( complex ); chars = transfer ( anything , chars ) type is ( complex ( kind = dp )); chars = transfer ( anything , chars ) type is ( integer ( kind = int8 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int16 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int32 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int64 )); chars = transfer ( anything , chars ) type is ( real ( kind = real32 )); chars = transfer ( anything , chars ) type is ( real ( kind = real64 )); chars = transfer ( anything , chars ) #ifdef HAS_REAL128 type is ( real ( kind = real128 )); chars = transfer ( anything , chars ) #endif type is ( logical ); chars = transfer ( anything , chars ) class default #ifdef __INTEL_LLVM_COMPILER stop 'crud. anything_to_bytes_arr(1) does not know about this type' #else chars = transfer ( anything , chars ) ! should work for everything, does not with some compilers #endif end select end function anything_to_bytes_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !!subroutine setany(anything,default,answer) !! !!$@(#) M_anything::setany(3fp): set absent parameter to default value !! !!class(*),intent(in),optional     :: anything !!class(*),intent(in)              :: default !!class(*),intent(out),allocatable :: answer !!if(present(anything))then !!   answer=anything !!else !!   answer=default !!endif !!end subroutine setany !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    anyscalar_to_real128(3f) - [M_anything] convert integer or real parameter of any kind to real128 !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    pure elemental function anyscalar_to_real128(valuein) result(d_out) !! !!     class(*),intent(in) :: valuein !!     real(kind=128)      :: d_out !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different !!    types. It is used to create other procedures that can take many !!    scalar arguments as input options. !! !!##OPTIONS !! !!    VALUEIN  input argument of a procedure to convert to type REAL128. !!             May be of KIND kind=int8, kind=int16, kind=int32, kind=int64, !!             kind=real32, kind=real64, or kind=real128 !! !!##RESULTS !! !!    D_OUT    The value of VALUIN converted to REAL128 (assuming !!             it is actually in the range of type REAL128). !! !!##EXAMPLE !! !! !!   Sample program !! !!     program demo_anyscalar_to_real128 !!     use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!     use, intrinsic :: iso_fortran_env, only : real32, real64, real128 !!     implicit none !!        ! call same function with many scalar input types !!        write(*,*)squarei(2_int8) !!        write(*,*)squarei(2_int16) !!        write(*,*)squarei(2_int32) !!        write(*,*)squarei(2_int64) !!        write(*,*)squarei(2.0_real32) !!        write(*,*)squarei(2.0_real64) !!        write(*,*)squarei(2.0_real128) !!     contains !! !!     function squarei(invalue) result (dvalue) !!     use M_anything, only : anyscalar_to_real128 !!     class(*),intent(in)  :: invalue !!     real(kind=real128)   :: invalue_local !!     real(kind=real128)   :: dvalue !!        invalue_local=anyscalar_to_real128(invalue) !!        dvalue=invalue_local*invalue_local !!     end function squarei !! !!     end program demo_anyscalar_to_real128 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT #ifdef HAS_REAL128 pure elemental function anyscalar_to_real128 ( valuein ) result ( d_out ) ! ident_3=\"@(#) M_anything anyscalar_to_real128(3f) convert integer or real parameter of any kind to real128\" class ( * ), intent ( in ) :: valuein real ( kind = real128 ) :: d_out character ( len = 3 ) :: readable select type ( valuein ) type is ( integer ( kind = int8 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int16 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int32 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int64 )); d_out = real ( valuein , kind = real128 ) type is ( real ( kind = real32 )); d_out = real ( valuein , kind = real128 ) type is ( real ( kind = real64 )); d_out = real ( valuein , kind = real128 ) Type is ( real ( kind = real128 )); d_out = valuein type is ( logical ); d_out = merge ( 0.0_real128 , 1.0_real128 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out class default readable = 'NaN' read ( readable , * ) d_out !!stop '*M_anything::anyscalar_to_real128: unknown type' end select end function anyscalar_to_real128 #endif !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    anyscalar_to_double(3f) - [M_anything] convert integer or real parameter of any kind to doubleprecision !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    pure elemental function anyscalar_to_double(valuein) result(d_out) !! !!     class(*),intent(in)  :: valuein !!     doubleprecision      :: d_out !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different !!    types. It is used to create other procedures that can take many !!    scalar arguments as input options. !! !!##OPTIONS !! !!    VALUEIN  input argument of a procedure to convert to type DOUBLEPRECISION. !!             May be of KIND kind=int8, kind=int16, kind=int32, kind=int64, !!             kind=real32, kind=real64, or kind=real128 !! !!##RESULTS !! !!    D_OUT    The value of VALUIN converted to doubleprecision (assuming !!             it is actually in the range of type DOUBLEPRECISION). !! !!##EXAMPLE !! !! !!   Sample program !! !!     program demo_anyscalar_to_double !!     use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!     use, intrinsic :: iso_fortran_env, only : real32, real64, real128 !!     implicit none !!        ! call same function with many scalar input types !!        write(*,*)squarei(2_int8) !!        write(*,*)squarei(2_int16) !!        write(*,*)squarei(2_int32) !!        write(*,*)squarei(2_int64) !!        write(*,*)squarei(2.0_real32) !!        write(*,*)squarei(2.0_real64) !!        write(*,*)squarei(2.0_real128) !!     contains !! !!     function squarei(invalue) result (dvalue) !!     use M_anything, only : anyscalar_to_double !!     class(*),intent(in)  :: invalue !!     doubleprecision      :: invalue_local !!     doubleprecision      :: dvalue !!        invalue_local=anyscalar_to_double(invalue) !!        dvalue=invalue_local*invalue_local !!     end function squarei !! !!     end program demo_anyscalar_to_double !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT pure elemental function anyscalar_to_double ( valuein ) result ( d_out ) ! ident_4=\"@(#) M_anything anyscalar_to_double(3f) convert integer or real parameter of any kind to doubleprecision\" class ( * ), intent ( in ) :: valuein doubleprecision :: d_out #ifdef HAS_REAL128 doubleprecision , parameter :: big = huge ( 0.0d0 ) #endif select type ( valuein ) type is ( integer ( kind = int8 )); d_out = dble ( valuein ) type is ( integer ( kind = int16 )); d_out = dble ( valuein ) type is ( integer ( kind = int32 )); d_out = dble ( valuein ) type is ( integer ( kind = int64 )); d_out = dble ( valuein ) type is ( real ( kind = real32 )); d_out = dble ( valuein ) type is ( real ( kind = real64 )); d_out = dble ( valuein ) #ifdef HAS_REAL128 Type is ( real ( kind = real128 )) !IMPURE! if(valuein > big)then !IMPURE!    write(stderr,'(*(g0,1x))')'*anyscalar_to_double* value too large ',valuein !IMPURE! endif d_out = dble ( valuein ) #endif type is ( logical ); d_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out class default !IMPURE! stop '*M_anything::anyscalar_to_double: unknown type' end select end function anyscalar_to_double !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    anyscalar_to_real(3f) - [M_anything] convert integer or real parameter of any kind to real !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    pure elemental function anyscalar_to_real(valuein) result(r_out) !! !!     class(*),intent(in)  :: valuein !!     real                 :: r_out !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different types. !!    It is used to create other procedures that can take !!    many scalar arguments as input options. !! !!##OPTIONS !! !!    VALUEIN  input argument of a procedure to convert to type REAL. !!             May be of KIND kind=int8, kind=int16, kind=int32, kind=int64, !!             kind=real32, kind=real64, or kind=real128. !! !!##RESULTS !! !!    R_OUT    The value of VALUIN converted to real (assuming it is actually !!             in the range of type REAL). !! !!##EXAMPLE !! !!   Sample program !! !!     program demo_anyscalar_to_real !!     use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!     use, intrinsic :: iso_fortran_env, only : real32, real64, real128 !!     implicit none !!        ! call same function with many scalar input types !!        write(*,*)squarei(2_int8) !!        write(*,*)squarei(2_int16) !!        write(*,*)squarei(2_int32) !!        write(*,*)squarei(2_int64) !!        write(*,*)squarei(2.0_real32) !!        write(*,*)squarei(2.0_real64) !!        write(*,*)squarei(2.0_real128) !!     contains !! !!     function squarei(invalue) result (dvalue) !!     use M_anything, only : anyscalar_to_real !!     class(*),intent(in)  :: invalue !!     real                 :: invalue_local !!     real                 :: dvalue !!        invalue_local=anyscalar_to_real(invalue) !!        dvalue=invalue_local*invalue_local !!     end function squarei !! !!     end program demo_anyscalar_to_real !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT pure elemental function anyscalar_to_real ( valuein ) result ( r_out ) ! ident_5=\"@(#) M_anything anyscalar_to_real(3f) convert integer or real parameter of any kind to real\" class ( * ), intent ( in ) :: valuein real :: r_out real , parameter :: big = huge ( 0.0 ) select type ( valuein ) type is ( integer ( kind = int8 )); r_out = real ( valuein ) type is ( integer ( kind = int16 )); r_out = real ( valuein ) type is ( integer ( kind = int32 )); r_out = real ( valuein ) type is ( integer ( kind = int64 )); r_out = real ( valuein ) type is ( real ( kind = real32 )); r_out = real ( valuein ) type is ( real ( kind = real64 )) !!if(valuein > big)then !!   write(stderr,*)'*anyscalar_to_real* value too large ',valuein !!endif r_out = real ( valuein ) #ifdef HAS_REAL128 type is ( real ( kind = real128 )) !!if(valuein > big)then !!   write(stderr,*)'*anyscalar_to_real* value too large ',valuein !!endif r_out = real ( valuein ) #endif type is ( logical ); r_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) r_out end select end function anyscalar_to_real !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !! !!    anyscalar_to_int64(3f) - [M_anything] convert intrinsic scalar types !!    to integer(kind=int64) !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!    impure elemental function anyscalar_to_int64(valin) result(value) !! !!     class(*),intent(in) :: valin !!     integer(kind=int64) :: value !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow arguments of different types !!    as input. It is typically used to create other procedures that can take !!    many scalar arguments as input options, equivalent to passing the !!    parameter VALUE as int(VALUE,0_int64) for integer; nint(VALUE,0_int64) !!    for real values, returning 0_int64 for .true. and 1_int64 for logical, !!    and the same as int(VALUE,0_int64) for character variables if the !!    character variables represent an integer value. !! !!##OPTIONS !! !!    VALUEIN  input argument of a procedure to convert to type INTEGER(KIND=int64). !! !!##RESULTS !!             The value of VALUIN converted to INTEGER(KIND=INT64). !!##EXAMPLE !! !!    Sample program !! !!     program demo_anyscalar_to_int64 !!     use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!     implicit none !!        ! call same function with many scalar input types !!        write(*,*)squarei(huge(0_int8)),huge(0_int8) , & !!        & '16129' !!        write(*,*)squarei(huge(0_int16)),huge(0_int16) , & !!        & '1073676289' !!        write(*,*)squarei(huge(0_int32)),huge(0_int32) , & !!        & '4611686014132420609' !!        write(*,*)squarei(huge(0_int64)),huge(0_int64) , & !!        & '85070591730234615847396907784232501249' !!     contains !!     ! !!     function squarei(invalue) !!     use M_anything, only : anyscalar_to_int64 !!     class(*),intent(in)  :: invalue !!     doubleprecision      :: invalue_local !!     doubleprecision      :: squarei !!        invalue_local=anyscalar_to_int64(invalue) !!        squarei=invalue_local*invalue_local !!     end function squarei !!     ! !!     end program demo_anyscalar_to_int64 !! !!   Results !! !!    16129.000000000000       127 \\ !!    16129 !!    1073676289.0000000       32767 \\ !!    1073676289 !!    4.6116860141324206E+018  2147483647 \\ !!    4611686014132420609 !!    8.5070591730234616E+037  9223372036854775807 \\ !!    85070591730234615847396907784232501249 !!    2.8948022309329049E+076 170141183460469231731687303715884105727 \\ !!    28948022309329048855892746252171976962977213799489202546401021394546514198529 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT impure elemental function anyscalar_to_int64 ( valuein ) result ( ii38 ) ! ident_6=\"@(#) M_anything anyscalar_to_int64(3f) convert parameter of any intrinsic kind to 64-bit integer\" class ( * ), intent ( in ) :: valuein integer ( kind = int64 ) :: ii38 integer :: ios character ( len = 256 ) :: message select type ( valuein ) type is ( integer ( kind = int8 )); ii38 = int ( valuein , kind = int64 ) type is ( integer ( kind = int16 )); ii38 = int ( valuein , kind = int64 ) type is ( integer ( kind = int32 )); ii38 = valuein type is ( integer ( kind = int64 )); ii38 = valuein type is ( real ( kind = real32 )); ii38 = nint ( valuein , kind = int64 ) type is ( real ( kind = real64 )); ii38 = nint ( valuein , kind = int64 ) #ifdef HAS_REAL128 Type is ( real ( kind = real128 )); ii38 = nint ( valuein , kind = int64 ) #endif type is ( logical ); ii38 = merge ( 0_int64 , 1_int64 , valuein ) type is ( character ( len =* )) ; read ( valuein , * , iostat = ios , iomsg = message ) ii38 if ( ios /= 0 ) then write ( stderr , * ) '*anyscalar_to_int64* ERROR: ' // trim ( message ) stop 2 endif class default write ( stderr , * ) '*anyscalar_to_int64* ERROR: unknown input type' stop 3 end select end function anyscalar_to_int64 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    anyscalar_to_string(3f) - [M_anything] converts up to twenty standard scalar type values to a string !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    Syntax: !! !!      pure function anyscalar_to_string(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& !!      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep) !!      class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9 !!      class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj !!      character(len=*),intent(in),optional :: sep !!      character,len=(:),allocatable :: anyscalar_to_string !! !!##DESCRIPTION !!    anyscalar_to_string(3f) builds a space-separated string from up to twenty scalar values. !! !!##OPTIONS !!    g[0-9a-j]   optional value to print the value of after the message. May !!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, !!                COMPLEX, or CHARACTER. !! !!                Optionally, all the generic values can be !!                single-dimensioned arrays. Currently, mixing scalar !!                arguments and array arguments is not supported. !! !!    sep         separator string used between values. Defaults to a space. !! !!##RETURNS !!    anyscalar_to_string     a representation of the input as a string !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_anyscalar_to_string !!    use M_anything, only : anyscalar_to_string !!    implicit none !!    character(len=:),allocatable :: pr !!    character(len=:),allocatable :: frmt !!    integer                      :: biggest !! !!    pr=anyscalar_to_string('HUGE(3f) integers',huge(0),& !!    &'and real',huge(0.0),'and double',huge(0.0d0)) !!    write(*,'(a)')pr !!    pr=anyscalar_to_string('real            :',huge(0.0),0.0,12345.6789,tiny(0.0) ) !!    write(*,'(a)')pr !!    pr=anyscalar_to_string('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) ) !!    write(*,'(a)')pr !!    pr=anyscalar_to_string('complex         :',cmplx(huge(0.0),tiny(0.0)) ) !!    write(*,'(a)')pr !! !!    ! create a format on the fly !!    biggest=huge(0) !!    frmt=anyscalar_to_string('(*(i',int(log10(real(biggest))),':,1x))',sep='') !!    write(*,*)'format=',frmt !! !!    ! although it will often work, using anyscalar_to_string(3f) !!    ! in an I/O statement is not recommended !!    ! because if an error occurs anyscalar_to_string(3f) will try !!    ! to write while part of an I/O statement !!    ! which not all compilers can handle and is currently non-standard !!    write(*,*)anyscalar_to_string('program will now stop') !! !!    end program demo_anyscalar_to_string !! !!  Output !! !!    HUGE(3f) integers 2147483647 and real 3.40282347E+38 !!    and double 1.7976931348623157E+308 !!    real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38 !!    doubleprecision : 1.7976931348623157E+308 0.0000000000000000 !!    12345.678900000001 2.2250738585072014E-308 !!    complex         : (3.40282347E+38,1.17549435E-38) !!     format=(*(i9:,1x)) !!     program will now stop !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT pure function anyscalar_to_string ( gen0 , gen1 , gen2 , gen3 , gen4 , gen5 , gen6 , gen7 , gen8 , gen9 , & & gena , genb , genc , gend , gene , genf , geng , genh , geni , genj , & & sep ) ! ident_7=\"@(#) M_anything anyscalar_to_string(3fp) writes a message to a string composed of any standard scalar types\" class ( * ), intent ( in ), optional :: gen0 , gen1 , gen2 , gen3 , gen4 class ( * ), intent ( in ), optional :: gen5 , gen6 , gen7 , gen8 , gen9 class ( * ), intent ( in ), optional :: gena , genb , genc , gend , gene class ( * ), intent ( in ), optional :: genf , geng , genh , geni , genj character ( len = :), allocatable :: anyscalar_to_string character ( len = 4096 ) :: line integer :: istart integer :: increment character ( len =* ), intent ( in ), optional :: sep character ( len = :), allocatable :: sep_local if ( present ( sep )) then increment = len ( sep ) + 1 sep_local = sep else increment = 2 sep_local = ' ' endif istart = 1 line = '' if ( present ( gen0 )) call print_generic ( gen0 , line , istart , increment , sep_local ) if ( present ( gen1 )) call print_generic ( gen1 , line , istart , increment , sep_local ) if ( present ( gen2 )) call print_generic ( gen2 , line , istart , increment , sep_local ) if ( present ( gen3 )) call print_generic ( gen3 , line , istart , increment , sep_local ) if ( present ( gen4 )) call print_generic ( gen4 , line , istart , increment , sep_local ) if ( present ( gen5 )) call print_generic ( gen5 , line , istart , increment , sep_local ) if ( present ( gen6 )) call print_generic ( gen6 , line , istart , increment , sep_local ) if ( present ( gen7 )) call print_generic ( gen7 , line , istart , increment , sep_local ) if ( present ( gen8 )) call print_generic ( gen8 , line , istart , increment , sep_local ) if ( present ( gen9 )) call print_generic ( gen9 , line , istart , increment , sep_local ) if ( present ( gena )) call print_generic ( gena , line , istart , increment , sep_local ) if ( present ( genb )) call print_generic ( genb , line , istart , increment , sep_local ) if ( present ( genc )) call print_generic ( genc , line , istart , increment , sep_local ) if ( present ( gend )) call print_generic ( gend , line , istart , increment , sep_local ) if ( present ( gene )) call print_generic ( gene , line , istart , increment , sep_local ) if ( present ( genf )) call print_generic ( genf , line , istart , increment , sep_local ) if ( present ( geng )) call print_generic ( geng , line , istart , increment , sep_local ) if ( present ( genh )) call print_generic ( genh , line , istart , increment , sep_local ) if ( present ( geni )) call print_generic ( geni , line , istart , increment , sep_local ) if ( present ( genj )) call print_generic ( genj , line , istart , increment , sep_local ) anyscalar_to_string = trim ( line ) contains !=================================================================================================================================== pure subroutine print_generic ( generic , line , istart , increment , sep ) class ( * ), intent ( in ) :: generic character ( len = 4096 ), intent ( inout ) :: line integer , intent ( inout ) :: istart integer , intent ( in ) :: increment character ( len =* ), intent ( in ) :: sep select type ( generic ) type is ( integer ( kind = int8 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int16 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int32 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int64 )); write ( line ( istart :), '(i0)' ) generic type is ( real ( kind = real32 )); write ( line ( istart :), '(1pg0)' ) generic type is ( real ( kind = real64 )); write ( line ( istart :), '(1pg0)' ) generic #ifdef HAS_REAL128 type is ( real ( kind = real128 )); write ( line ( istart :), '(1pg0)' ) generic #endif type is ( logical ); write ( line ( istart :), '(l1)' ) generic type is ( character ( len =* )); write ( line ( istart :), '(a)' ) trim ( generic ) type is ( complex ); write ( line ( istart :), '(\"(\",1pg0,\",\",1pg0,\")\")' ) generic end select istart = len_trim ( line ) + increment line = trim ( line ) // sep end subroutine print_generic end function anyscalar_to_string !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !! !!    anyinteger_to_string(3f) - [M_anything] convert integer of any kind to a string !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    impure function anyinteger_to_string(intin) result(str) !! !!     character(len=:),allocatable :: anyinteger_to_string !!     class(*),intent(in)          :: intin !! !!##DESCRIPTION !! !!    Converts an integer value to a string representing the value. !!    This function allows arguments of different INTEGER types as input. !! !!##OPTIONS !! !!    VALUEIN  INTEGER input argument to be converted to a string. !!             May be of KIND kind=int8, kind=int16, kind=int32, kind=int64. !! !!##RESULTS !!             The value of VALUIN converted to a CHARACTER string. !! !!##EXAMPLE !! !! !!   Sample program !! !!    program demo_anyinteger_to_string !!    use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!    use M_anything, only : itoc=>anyinteger_to_string !!    implicit none !!       write(*,*)itoc(huge(0_int8)),       '=> 127' !!       write(*,*)itoc(huge(0_int16)),      '=> 32767' !!       write(*,*)itoc(huge(0_int32)),      '=> 2147483647' !!       write(*,*)itoc(huge(0_int64)),      '=> 9223372036854775807',huge(0_int64) !!       write(*,*)itoc(-(huge(0_int64)-1)), '=> -9223372036854775806' !!    end program demo_anyinteger_to_string !! !!   Results: !! !!    127=> 127 !!    32767=> 32767 !!    2147483647=> 2147483647 !!    9223372036854775807=> 9223372036854775807 !!    -9223372036854775806=> -9223372036854775806 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT impure function anyinteger_to_string ( int ) result ( out ) ! ident_8=\"@(#) M_anything anyinteger_to_string(3f) function that converts an integer value to a character string\" class ( * ), intent ( in ) :: int character ( len = :), allocatable :: out integer , parameter :: maxlen = 32 ! assumed more than enough characters for largest input value integer :: i , k integer ( kind = int64 ) :: intval integer ( kind = int64 ) :: int_local integer :: str ( maxlen ) integer , parameter :: dig0 = ichar ( '0' ) integer , parameter :: minus = ichar ( '-' ) int_local = anyscalar_to_int64 ( int ) ! convert input to largest integer type intval = abs ( int_local ) do i = 1 , maxlen ! generate digits from smallest significant digit to largest str ( i ) = dig0 + mod ( intval , 10_int64 ) intval = intval / 10 if ( intval == 0 ) exit enddo if ( int_local < 0 ) then ! now make sure the sign is correct i = i + 1 str ( i ) = minus endif allocate ( character ( len = i ) :: out ) do k = i , 1 , - 1 ! have all the digits in reverse order, now flip them and convert to a string out ( i - k + 1 : i - k + 1 ) = char ( str ( k )) enddo end function anyinteger_to_string !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    get_type(3f) - [M_anything] return array of strings containing type !!    names of arguments !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    function get_type(anything) result(chars) !! !!     class(*),intent(in)  :: anything !!             or !!     class(*),intent(in)  :: anything(..) !! !!     character(len=:),allocatable :: chars !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different !!    types. It is used by other procedures that can take many !!    argument types as input options. !! !!##OPTIONS !! !!    VALUEIN  input array or scalar to return type of !!             May be of KIND INTEGER(kind=int8), INTEGER(kind=int16), !!             INTEGER(kind=int32), INTEGER(kind=int64), !!             REAL(kind=real32, REAL(kind=real64), !!             REAL(kind=real128), complex, or CHARACTER(len=*) !!##RETURN !! !!    CHARS    The returned value is an array of names !! !!##EXAMPLE !! !! !!   Sample program !! !!    program demo_get_type !!    use M_anything,      only : get_type !!    implicit none !!    integer :: i !!       write(*,*)get_type([(i*i,i=1,10)]) !!       write(*,*)get_type([11.11,22.22,33.33]) !!       write(*,*)get_type('This is a string') !!       write(*,*)get_type(30.0d0) !!    end program demo_get_type !! !!   Results: !! !!     int32 !!     real32 !!     character !!     real64 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    MIT function get_type_arr ( anything ) result ( chars ) ! ident_9=\"@(#) M_anything get_type_arr(3fp) any vector of intrinsics to bytes (an array of CHARACTER(LEN=1) variables)\" class ( * ), intent ( in ) :: anything (:) ! anything(..) character ( len = 20 ) :: chars select type ( anything ) type is ( character ( len =* )); chars = 'character' type is ( complex ); chars = 'complex' type is ( complex ( kind = dp )); chars = 'complex_real64' type is ( integer ( kind = int8 )); chars = 'int8' type is ( integer ( kind = int16 )); chars = 'int16' type is ( integer ( kind = int32 )); chars = 'int32' type is ( integer ( kind = int64 )); chars = 'int64' type is ( real ( kind = real32 )); chars = 'real32' type is ( real ( kind = real64 )); chars = 'real64' #ifdef HAS_REAL128 type is ( real ( kind = real128 )); chars = 'real128' #endif type is ( logical ); chars = 'logical' class default stop 'crud. get_type_arr(1) does not know about this type' end select end function get_type_arr !----------------------------------------------------------------------------------------------------------------------------------- elemental impure function get_type_scalar ( anything ) result ( chars ) ! ident_10=\"@(#) M_anything get_type_scalar(3fp) anything to bytes (an array of CHARACTER(LEN=1) variables)\" class ( * ), intent ( in ) :: anything character ( len = 20 ) :: chars select type ( anything ) type is ( character ( len =* )); chars = 'character' type is ( complex ); chars = 'complex' type is ( complex ( kind = dp )); chars = 'complex_real64' type is ( integer ( kind = int8 )); chars = 'int8' type is ( integer ( kind = int16 )); chars = 'int16' type is ( integer ( kind = int32 )); chars = 'int32' type is ( integer ( kind = int64 )); chars = 'int64' type is ( real ( kind = real32 )); chars = 'real32' type is ( real ( kind = real64 )); chars = 'real64' #ifdef HAS_REAL128 type is ( real ( kind = real128 )); chars = 'real128' #endif type is ( logical ); chars = 'logical' class default stop 'crud. get_type_scalar(1) does not know about this type' end select end function get_type_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_anything !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","url":"sourcefile/m_anything.f90.html"},{"title":"demo_anything_to_bytes.f90 – M_anything","text":"Source Code program demo_anything_to_bytes use M_anything , only : anything_to_bytes implicit none integer :: i write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ([( i * i , i = 1 , 10 )]) write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ([ 1 1.11 , 2 2.22 , 3 3.33 ]) write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ( 'This is a string' ) end program demo_anything_to_bytes","tags":"","url":"sourcefile/demo_anything_to_bytes.f90.html"},{"title":"demo_anyscalar_to_int64.f90 – M_anything","text":"Source Code program demo_anyscalar_to_int64 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( huge ( 0_int8 )), huge ( 0_int8 ) , & & '16129' write ( * , * ) squarei ( huge ( 0_int16 )), huge ( 0_int16 ) , & & '1073676289' write ( * , * ) squarei ( huge ( 0_int32 )), huge ( 0_int32 ) , & & '4611686014132420609' write ( * , * ) squarei ( huge ( 0_int64 )), huge ( 0_int64 ) , & & '85070591730234615847396907784232501249' contains ! function squarei ( invalue ) use M_anything , only : anyscalar_to_int64 class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: squarei invalue_local = anyscalar_to_int64 ( invalue ) squarei = invalue_local * invalue_local end function squarei ! end program demo_anyscalar_to_int64","tags":"","url":"sourcefile/demo_anyscalar_to_int64.f90.html"},{"title":"demo_anyscalar_to_real.f90 – M_anything","text":"Source Code program demo_anyscalar_to_real use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2_int8 ) write ( * , * ) squarei ( 2_int16 ) write ( * , * ) squarei ( 2_int32 ) write ( * , * ) squarei ( 2_int64 ) write ( * , * ) squarei ( 2.0_real32 ) write ( * , * ) squarei ( 2.0_real64 ) write ( * , * ) squarei ( 2.0_real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue invalue_local = anyscalar_to_real ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_real","tags":"","url":"sourcefile/demo_anyscalar_to_real.f90.html"},{"title":"scalars.f90 – M_anything","text":"Source Code program scalars use M_anything , only : anyscalar_to_real use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none integer :: ios integer ( kind = int8 ) :: tiny = huge ( 0_int8 ) integer ( kind = int16 ) :: small = huge ( 0_int16 ) integer ( kind = int32 ) :: medium = huge ( 0_int32 ) integer ( kind = int64 ) :: large = huge ( 0_int64 ) real ( kind = real32 ) :: rs = huge ( 0.0_real32 ) real ( kind = real64 ) :: rm = huge ( 0.0_real64 ) real ( kind = real128 ) :: rl = huge ( 0.0_real128 ) 101 format ( a10 , \"|\" , i39 , \"|\" , i11 , \"|\" , i39 ) 102 format ( a10 , \"|\" , g0 , t55 , \"|\" , i11 , \"|\" , g0 ) write ( * , * ) 'First show the intrinsic variables of various KINDS we will be using' write ( * , * ) '  NAME   |VALUE                                  |KIND(VALUE)|10**RANGE(VALUE)' write ( * , 102 ) 'rs     ' , rs , kind ( rs ), 1 0.0_real32 ** range ( rs ) write ( * , 102 ) 'rm     ' , rm , kind ( rm ), 1 0.0_real64 ** range ( rm ) write ( * , 102 ) 'rl     ' , rl , kind ( rl ), 1 0.0_real128 ** range ( rl ) write ( * , 102 ) 'tiny   ' , tiny , kind ( tiny ) write ( * , 102 ) 'small  ' , small , kind ( small ) write ( * , 102 ) 'medium ' , medium , kind ( medium ) write ( * , 102 ) 'large  ' , large , kind ( large ) write ( * , * ) 'Test squarei with all INTEGER KINDs:' write ( * , * ) '(and given the following facts what is the expected output?)' write ( * , * ) 'FACTS:' write ( * , * ) '127 * 127 = 16129' write ( * , * ) '32767 * 32767 = 1073676289' write ( * , * ) '2147483647 * 2147483647 = 4611686014132420609' write ( * , * ) '9223372036854775807 * 9223372036854775807 = 85070591730234615847396907784232501249' write ( * , * ) '170141183460469231731687303715884105727 * 170141183460469231731687303715884105727 =& &28948022309329048855892746252171976962977213799489202546401021394546514198529' write ( * , * ) 'OUTPUT:' 202 format ( a , * ( g0 :, '; ' )) write ( * , 202 , iostat = ios ) 'SQUAREI()  :' , squarei ( tiny ), squarei ( small ), squarei ( medium ), squarei ( large ) write ( * , 202 , iostat = ios ) 'SQUAREI()  :' , squarei ( rs ), squarei ( rm ), squarei ( rl ) contains !! THIS FUNCTION CAN TAKE AN INTEGER OR REAL OF ANY TYPE KNOWN TO ANYSCALAR_TO_REAL() AS AN ARGUMENT function squarei ( invalue ) result ( dvalue ) ! square an integer value generically use M_anything , only : anyscalar_to_real implicit none class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue real , parameter :: biggest = sqrt ( real ( 0.0 , kind = real128 )) invalue_local = anyscalar_to_real ( invalue ) !if(invalue_local.gt.biggest)then !   write(*,*)'ERROR:*squarei* input value to big=',invalue_local !endif dvalue = invalue_local * invalue_local end function squarei end program scalars","tags":"","url":"sourcefile/scalars.f90.html"}]}