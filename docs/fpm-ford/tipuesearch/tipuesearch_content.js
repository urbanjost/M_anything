var tipuesearch = {"pages":[{"title":" M_anything ","text":"M_anything Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"M_anything.f90 – M_anything","text":"Contents Modules M_anything Source Code M_anything.f90 Source Code !=================================================================================================================================== ! This module and the example function squarei() that uses it shows how you ! can use polymorphism to allow arguments of different types generically by casting !=================================================================================================================================== !> !!##NAME !!    M_anything(3fm) - [M_anything::INTRO] procedures that use polymorphism to allow arguments of different types generically !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!   use M_anything,only : anyinteger_to_string !!   use M_anything,only : anyscalar_to_int64 !!   use M_anything,only : anyscalar_to_real !!   use M_anything,only : anyscalar_to_real128 !!   use M_anything,only : anyscalar_to_double !!   use M_anything,only : anything_to_bytes !!   use M_anything,only : bytes_to_anything !!   use M_anything,only : empty, assignment(=) !! !!##DESCRIPTION !!    anyinteger_to_string    convert integer parameter of any kind to string !!    anyscalar_to_int64      convert integer parameter of any kind to 64-bit integer !!    anyscalar_to_real       convert integer or real parameter of any kind to real !!    anyscalar_to_real128    convert integer or real parameter of any kind to real128 !!    anyscalar_to_double     convert integer or real parameter of any kind to doubleprecision !!    anything_to_bytes       convert anything to bytes !!    empty                   create an empty array !! !!##EXAMPLE !! !! !! At the cost of casting to a different type these functions can !! (among other uses such as in linked lists) allow for an alternative !! to duplicating code using generic procedure methods. For example, !! the following SQUAREALL function can take many input types and return a !! DOUBLEPRECISION value (it is a trivial example for demonstration purposes, !! and does not check for overflow, etc.).: !! !!   Sample program !! !!     program demo_anyscalar_to_double !!     use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!     use, intrinsic :: iso_fortran_env, only : real32, real64, real128 !!     implicit none !!        ! call same function with many scalar input types !!        write(*,*)squareall(2_int8) !!        write(*,*)squareall(2_int16) !!        write(*,*)squareall(2_int32) !!        write(*,*)squareall(2_int64) !!        write(*,*)squareall(2.0_real32) !!        write(*,*)squareall(2.0_real64) !!        write(*,*)squareall(2.0_real128) !!     contains !! !!     function squareall(invalue) result (dvalue) !!     use M_anything, only : anyscalar_to_double !!     class(*),intent(in)  :: invalue !!     doubleprecision      :: invalue_local !!     doubleprecision      :: dvalue !!        invalue_local=anyscalar_to_double(invalue) !!        dvalue=invalue_local*invalue_local !!     end function squareall !! !!     end program demo_anyscalar_to_double !! !!   Results: !! !!       4.00000000000000 !!       4.00000000000000 !!       4.00000000000000 !!       4.00000000000000 !!       4.00000000000000 !!       4.00000000000000 !!       4.00000000000000 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT module M_anything use , intrinsic :: ISO_FORTRAN_ENV , only : INT8 , INT16 , INT32 , INT64 !  1           2           4           8 use , intrinsic :: ISO_FORTRAN_ENV , only : REAL32 , REAL64 , REAL128 !  4           8          10 implicit none private integer , parameter :: dp = kind ( 0.0d0 ) public anyinteger_to_string ! convert integer parameter of any kind to string public anyscalar_to_int64 ! convert integer parameter of any kind to 64-bit integer public anyscalar_to_real ! convert integer or real parameter of any kind to real public anyscalar_to_real128 ! convert integer or real parameter of any kind to real128 public anyscalar_to_double ! convert integer or real parameter of any kind to doubleprecision public anything_to_bytes public bytes_to_anything !!public setany interface anything_to_bytes module procedure anything_to_bytes_arr module procedure anything_to_bytes_scalar end interface anything_to_bytes !=================================================================================================================================== !   Because there is no builtin \"empty array\" object, I've tried to mimic !   it with some user-defined type (just for fun).  -- spectrum ! ! So, if there is a language support, it might be not too difficult ! to think of a common \"empty array\" thing (though not sure if it is ! sufficiently useful). ! public empty , assignment ( = ) type Empty_t endtype type ( Empty_t ) empty !! singleton interface assignment ( = ) module procedure & & ints_empty_ , & & reals_empty_ , & & doubles_empty_ , & & strings_empty_ endinterface contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    empty(3f) - [M_anything] set an allocatable array to zero !!    (LICENSE:MIT) !!##SYNOPSIS !! !!    use M_anything, only : empty, assignment(=) !!##DESCRIPTION !!    A convenience routine that sets an array to an empty set. !!##EXAMPLE !! !! !!   Sample program: !! !!    program demo_empty_ !!    use M_anything, only : empty, assignment(=) !!    integer, allocatable      :: ints(:) !!    character(:), allocatable :: strs(:) !!    real, allocatable      :: reals(:) !!       ints=empty !!       write(*,*)size(ints) !! !!       write(*,*)'give them some size ...' !!       reals = [1.0,2.0,3.0] !!       ints = [1,2,3] !!       strs = [character(len=10) :: \"one\",\"two\",\"three\",\"four\"] !!       write(*,*)size(ints) !!       write(*,*)size(reals) !!       write(*,*)size(strs) !! !!       ints=empty !!       reals=empty !!       strs=empty !!       write(*,*)'back to empty ...' !!       write(*,*)size(ints) !!       write(*,*)size(reals) !!       write(*,*)size(strs) !! !!    end program demo_empty_ !! !!   Expected output: !! !!    >             0 !!    >   give them some size ... !!    >             3 !!    >             3 !!    >             4 !!    >   back to empty ... !!    >             0 !!    >             0 !!    >             0 !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT subroutine ints_empty_ ( x , emp ) integer , allocatable , intent ( inout ) :: x (:) type ( Empty_t ), intent ( in ) :: emp if ( allocated ( x ) ) deallocate ( x ) allocate ( x ( 0 ) ) end subroutine ints_empty_ subroutine doubles_empty_ ( x , emp ) doubleprecision , allocatable , intent ( inout ) :: x (:) type ( Empty_t ), intent ( in ) :: emp if ( allocated ( x ) ) deallocate ( x ) allocate ( x ( 0 ) ) end subroutine doubles_empty_ subroutine reals_empty_ ( x , emp ) real , allocatable , intent ( inout ) :: x (:) type ( Empty_t ), intent ( in ) :: emp if ( allocated ( x ) ) deallocate ( x ) allocate ( x ( 0 ) ) end subroutine reals_empty_ subroutine strings_empty_ ( x , emp ) character (:), allocatable , intent ( inout ) :: x (:) type ( Empty_t ), intent ( in ) :: emp if ( allocated ( x ) ) deallocate ( x ) allocate ( character ( 0 ) :: x ( 0 ) ) end subroutine strings_empty_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    bytes_to_anything(3f) - [M_anything] convert bytes(character)len=1):: array(:)) to standard types !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!   subroutine bytes_to_anything(chars,anything) !! !!    character(len=1),allocatable :: chars(:) !!    class(*) :: anything !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different !!    types. It is used to create other procedures that can take many !!    argument types as input options and convert them to a single type !!    to simplify storing arbitrary data, to simplify generating data !!    hashes, ... !! !!##OPTIONS !!    CHARS     The input value is an array of bytes (character(len=1)). !! !!##RETURN !!    ANYTHING  May be of KIND INTEGER(kind=int8), INTEGER(kind=int16), !!              INTEGER(kind=int32), INTEGER(kind=int64), !!              REAL(kind=real32, REAL(kind=real64), !!              REAL(kind=real128), complex, or CHARACTER(len=*) !! !!##EXAMPLE !! !! !!   Sample program !! !!   Expected output !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    MIT subroutine bytes_to_anything ( chars , anything ) character ( len = 1 ), allocatable :: chars (:) class ( * ) :: anything select type ( anything ) type is ( character ( len =* )); anything = transfer ( chars , anything ) type is ( complex ); anything = transfer ( chars , anything ) type is ( complex ( kind = dp )); anything = transfer ( chars , anything ) type is ( integer ( kind = int8 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int16 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int32 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int64 )); anything = transfer ( chars , anything ) type is ( real ( kind = real32 )); anything = transfer ( chars , anything ) type is ( real ( kind = real64 )); anything = transfer ( chars , anything ) type is ( real ( kind = real128 )); anything = transfer ( chars , anything ) type is ( logical ); anything = transfer ( chars , anything ) class default stop 'crud. bytes_to_anything(1) does not know about this type' end select end subroutine bytes_to_anything !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    anything_to_bytes(3f) - [M_anything] convert standard types to bytes (character(len=1):: array(:)) !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    function anything_to_bytes_arr(anything) result(chars) !! !!     class(*),intent(in)  :: anything !!             or !!     class(*),intent(in)  :: anything(:) !! !!     character(len=1),allocatable :: chars(:) !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different !!    types. It is used to create other procedures that can take many !!    argument types as input options and convert them to a single type !!    to simplify storing arbitrary data, to simplify generating data !!    hashes, ... !! !!##OPTIONS !! !!    VALUEIN  input array or scalar to convert to type CHARACTER(LEN=1). !!             May be of KIND INTEGER(kind=int8), INTEGER(kind=int16), !!             INTEGER(kind=int32), INTEGER(kind=int64), !!             REAL(kind=real32, REAL(kind=real64), !!             REAL(kind=real128), complex, or CHARACTER(len=*) !!##RETURN !! !!    CHARS    The returned value is an array of bytes (character(len=1)). !! !!##EXAMPLE !! !! !!   Sample program !! !!    program demo_anything_to_bytes !!    use M_anything,      only : anything_to_bytes !!    !!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!    !!use, intrinsic :: iso_fortran_env, only : real32, real64, real128 !!    implicit none !!    integer :: i !!       write(*,'(/,4(1x,z2.2))')anything_to_bytes([(i*i,i=1,10)]) !!       write(*,'(/,4(1x,z2.2))')anything_to_bytes([11.11,22.22,33.33]) !!       write(*,'(/,4(1x,z2.2))')anything_to_bytes('This is a string') !!    end program demo_anything_to_bytes !! !!   Expected output !! !!        01 00 00 00 !!        04 00 00 00 !!        09 00 00 00 !!        10 00 00 00 !!        19 00 00 00 !!        24 00 00 00 !!        31 00 00 00 !!        40 00 00 00 !!        51 00 00 00 !!        64 00 00 00 !! !!        8F C2 31 41 !!        8F C2 B1 41 !!        EC 51 05 42 !! !!        54 68 69 73 !!        20 69 73 20 !!        61 20 73 74 !!        72 69 6E 67 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    MIT function anything_to_bytes_arr ( anything ) result ( chars ) implicit none ! ident_1=\"@(#)M_anything::anything_to_bytes_arr(3fp): any vector of intrinsics to bytes (an array of CHARACTER(LEN=1) variables)\" class ( * ), intent ( in ) :: anything (:) character ( len = 1 ), allocatable :: chars (:) select type ( anything ) type is ( character ( len =* )); chars = transfer ( anything , chars ) type is ( complex ); chars = transfer ( anything , chars ) type is ( complex ( kind = dp )); chars = transfer ( anything , chars ) type is ( integer ( kind = int8 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int16 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int32 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int64 )); chars = transfer ( anything , chars ) type is ( real ( kind = real32 )); chars = transfer ( anything , chars ) type is ( real ( kind = real64 )); chars = transfer ( anything , chars ) type is ( real ( kind = real128 )); chars = transfer ( anything , chars ) type is ( logical ); chars = transfer ( anything , chars ) class default stop 'crud. anything_to_bytes_arr(1) does not know about this type' end select end function anything_to_bytes_arr !----------------------------------------------------------------------------------------------------------------------------------- function anything_to_bytes_scalar ( anything ) result ( chars ) implicit none ! ident_2=\"@(#)M_anything::anything_to_bytes_scalar(3fp): anything to bytes (an array of CHARACTER(LEN=1) variables)\" class ( * ), intent ( in ) :: anything character ( len = 1 ), allocatable :: chars (:) select type ( anything ) type is ( character ( len =* )); chars = transfer ( anything , chars ) type is ( complex ); chars = transfer ( anything , chars ) type is ( complex ( kind = dp )); chars = transfer ( anything , chars ) type is ( integer ( kind = int8 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int16 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int32 )); chars = transfer ( anything , chars ) type is ( integer ( kind = int64 )); chars = transfer ( anything , chars ) type is ( real ( kind = real32 )); chars = transfer ( anything , chars ) type is ( real ( kind = real64 )); chars = transfer ( anything , chars ) type is ( real ( kind = real128 )); chars = transfer ( anything , chars ) type is ( logical ); chars = transfer ( anything , chars ) class default stop 'crud. anything_to_bytes_scalar(1) does not know about this type' end select end function anything_to_bytes_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !!subroutine setany(anything,default,answer) !!implicit none !! !!$@(#) M_anything::setany(3fp): set absent parameter to default value !! !!class(*),intent(in),optional     :: anything !!class(*),intent(in)              :: default !!class(*),intent(out),allocatable :: answer !!if(present(anything))then !!   answer=anything !!else !!   answer=default !!endif !!end subroutine setany !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    anyscalar_to_real128(3f) - [M_anything] convert integer or real parameter of any kind to real128 !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    pure elemental function anyscalar_to_real128(valuein) result(d_out) !! !!     class(*),intent(in) :: valuein !!     real(kind=128)      :: d_out !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different !!    types. It is used to create other procedures that can take many !!    scalar arguments as input options. !! !!##OPTIONS !! !!    VALUEIN  input argument of a procedure to convert to type REAL128. !!             May be of KIND kind=int8, kind=int16, kind=int32, kind=int64, !!             kind=real32, kind=real64, or kind=real128 !! !!##RESULTS !! !!    D_OUT    The value of VALUIN converted to REAL128 (assuming !!             it is actually in the range of type REAL128). !! !!##EXAMPLE !! !! !!   Sample program !! !!     program demo_anyscalar_to_real128 !!     use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!     use, intrinsic :: iso_fortran_env, only : real32, real64, real128 !!     implicit none !!        ! call same function with many scalar input types !!        write(*,*)squarei(2_int8) !!        write(*,*)squarei(2_int16) !!        write(*,*)squarei(2_int32) !!        write(*,*)squarei(2_int64) !!        write(*,*)squarei(2.0_real32) !!        write(*,*)squarei(2.0_real64) !!        write(*,*)squarei(2.0_real128) !!     contains !! !!     function squarei(invalue) result (dvalue) !!     use M_anything, only : anyscalar_to_real128 !!     class(*),intent(in)  :: invalue !!     real(kind=real128)   :: invalue_local !!     real(kind=real128)   :: dvalue !!        invalue_local=anyscalar_to_real128(invalue) !!        dvalue=invalue_local*invalue_local !!     end function squarei !! !!     end program demo_anyscalar_to_real128 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT pure elemental function anyscalar_to_real128 ( valuein ) result ( d_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none ! ident_3=\"@(#)M_anything::anyscalar_to_real128(3f): convert integer or real parameter of any kind to real128\" class ( * ), intent ( in ) :: valuein real ( kind = real128 ) :: d_out character ( len = 3 ) :: readable select type ( valuein ) type is ( integer ( kind = int8 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int16 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int32 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int64 )); d_out = real ( valuein , kind = real128 ) type is ( real ( kind = real32 )); d_out = real ( valuein , kind = real128 ) type is ( real ( kind = real64 )); d_out = real ( valuein , kind = real128 ) Type is ( real ( kind = real128 )); d_out = valuein type is ( logical ); d_out = merge ( 0.0_real128 , 1.0_real128 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out class default !!d_out=huge(0.0_real128) readable = 'NaN' read ( readable , * ) d_out !!stop '*M_anything::anyscalar_to_real128: unknown type' end select end function anyscalar_to_real128 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    anyscalar_to_double(3f) - [M_anything] convert integer or real parameter of any kind to doubleprecision !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    pure elemental function anyscalar_to_double(valuein) result(d_out) !! !!     class(*),intent(in)  :: valuein !!     doubleprecision      :: d_out !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different !!    types. It is used to create other procedures that can take many !!    scalar arguments as input options. !! !!##OPTIONS !! !!    VALUEIN  input argument of a procedure to convert to type DOUBLEPRECISION. !!             May be of KIND kind=int8, kind=int16, kind=int32, kind=int64, !!             kind=real32, kind=real64, or kind=real128 !! !!##RESULTS !! !!    D_OUT    The value of VALUIN converted to doubleprecision (assuming !!             it is actually in the range of type DOUBLEPRECISION). !! !!##EXAMPLE !! !! !!   Sample program !! !!     program demo_anyscalar_to_double !!     use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!     use, intrinsic :: iso_fortran_env, only : real32, real64, real128 !!     implicit none !!        ! call same function with many scalar input types !!        write(*,*)squarei(2_int8) !!        write(*,*)squarei(2_int16) !!        write(*,*)squarei(2_int32) !!        write(*,*)squarei(2_int64) !!        write(*,*)squarei(2.0_real32) !!        write(*,*)squarei(2.0_real64) !!        write(*,*)squarei(2.0_real128) !!     contains !! !!     function squarei(invalue) result (dvalue) !!     use M_anything, only : anyscalar_to_double !!     class(*),intent(in)  :: invalue !!     doubleprecision      :: invalue_local !!     doubleprecision      :: dvalue !!        invalue_local=anyscalar_to_double(invalue) !!        dvalue=invalue_local*invalue_local !!     end function squarei !! !!     end program demo_anyscalar_to_double !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT pure elemental function anyscalar_to_double ( valuein ) result ( d_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none ! ident_4=\"@(#)M_anything::anyscalar_to_double(3f): convert integer or real parameter of any kind to doubleprecision\" class ( * ), intent ( in ) :: valuein doubleprecision :: d_out doubleprecision , parameter :: big = huge ( 0.0d0 ) select type ( valuein ) type is ( integer ( kind = int8 )); d_out = dble ( valuein ) type is ( integer ( kind = int16 )); d_out = dble ( valuein ) type is ( integer ( kind = int32 )); d_out = dble ( valuein ) type is ( integer ( kind = int64 )); d_out = dble ( valuein ) type is ( real ( kind = real32 )); d_out = dble ( valuein ) type is ( real ( kind = real64 )); d_out = dble ( valuein ) Type is ( real ( kind = real128 )) !!if(valuein.gt.big)then !!   write(error_unit,*)'*anyscalar_to_double* value too large ',valuein !!endif d_out = dble ( valuein ) type is ( logical ); d_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out !type is (real(kind=real128)) !   if(valuein.gt.big)then !      write(error_unit,*)'*anyscalar_to_double* value too large ',valuein !   endif !   d_out=dble(valuein) class default d_out = 0.0d0 !!stop '*M_anything::anyscalar_to_double: unknown type' end select end function anyscalar_to_double !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    anyscalar_to_real(3f) - [M_anything] convert integer or real parameter of any kind to real !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    pure elemental function anyscalar_to_real(valuein) result(r_out) !! !!     class(*),intent(in)  :: valuein !!     real                 :: r_out !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow input arguments of different types. !!    It is used to create other procedures that can take !!    many scalar arguments as input options. !! !!##OPTIONS !! !!    VALUEIN  input argument of a procedure to convert to type REAL. !!             May be of KIND kind=int8, kind=int16, kind=int32, kind=int64, !!             kind=real32, kind=real64, or kind=real128. !! !!##RESULTS !! !!    R_OUT    The value of VALUIN converted to real (assuming it is actually !!             in the range of type REAL). !! !!##EXAMPLE !! !!   Sample program !! !!     program demo_anyscalar_to_real !!     use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!     use, intrinsic :: iso_fortran_env, only : real32, real64, real128 !!     implicit none !!        ! call same function with many scalar input types !!        write(*,*)squarei(2_int8) !!        write(*,*)squarei(2_int16) !!        write(*,*)squarei(2_int32) !!        write(*,*)squarei(2_int64) !!        write(*,*)squarei(2.0_real32) !!        write(*,*)squarei(2.0_real64) !!        write(*,*)squarei(2.0_real128) !!     contains !! !!     function squarei(invalue) result (dvalue) !!     use M_anything, only : anyscalar_to_real !!     class(*),intent(in)  :: invalue !!     real                 :: invalue_local !!     real                 :: dvalue !!        invalue_local=anyscalar_to_real(invalue) !!        dvalue=invalue_local*invalue_local !!     end function squarei !! !!     end program demo_anyscalar_to_real !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT pure elemental function anyscalar_to_real ( valuein ) result ( r_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none ! ident_5=\"@(#)M_anything::anyscalar_to_real(3f): convert integer or real parameter of any kind to real\" class ( * ), intent ( in ) :: valuein real :: r_out real , parameter :: big = huge ( 0.0 ) select type ( valuein ) type is ( integer ( kind = int8 )); r_out = real ( valuein ) type is ( integer ( kind = int16 )); r_out = real ( valuein ) type is ( integer ( kind = int32 )); r_out = real ( valuein ) type is ( integer ( kind = int64 )); r_out = real ( valuein ) type is ( real ( kind = real32 )); r_out = real ( valuein ) type is ( real ( kind = real64 )) !!if(valuein.gt.big)then !!   write(error_unit,*)'*anyscalar_to_real* value too large ',valuein !!endif r_out = real ( valuein ) type is ( real ( kind = real128 )) !!if(valuein.gt.big)then !!   write(error_unit,*)'*anyscalar_to_real* value too large ',valuein !!endif r_out = real ( valuein ) type is ( logical ); r_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) r_out !type is (real(kind=real128));  r_out=real(valuein) end select end function anyscalar_to_real !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !! !!    anyscalar_to_int64(3f) - [M_anything] convert integer any kind to integer(kind=int64) !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!    impure elemental function anyscalar_to_int64(intin) result(value) !! !!     class(*),intent(in) :: intin !!     integer(kind=int64) :: value !! !!##DESCRIPTION !! !!    This function uses polymorphism to allow arguments of different INTEGER types !!    as input. It is typically used to create other procedures that can take !!    many scalar arguments as input options, equivalent to passing the !!    parameter VALUE as int(VALUE,0_int64). !! !!##OPTIONS !! !!    VALUEIN  input argument of a procedure to convert to type INTEGER(KIND=int64). !!             May be of KIND kind=int8, kind=int16, kind=int32, kind=int64. !! !!##RESULTS !!             The value of VALUIN converted to INTEGER(KIND=INT64). !!##EXAMPLE !! !!    Sample program !! !!     program demo_anyscalar_to_int64 !!     use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!     implicit none !!        ! call same function with many scalar input types !!        write(*,*)squarei(huge(0_int8)),huge(0_int8) , & !!        & '16129' !!        write(*,*)squarei(huge(0_int16)),huge(0_int16) , & !!        & '1073676289' !!        write(*,*)squarei(huge(0_int32)),huge(0_int32) , & !!        & '4611686014132420609' !!        write(*,*)squarei(huge(0_int64)),huge(0_int64) , & !!        & '85070591730234615847396907784232501249' !!     contains !!     ! !!     function squarei(invalue) !!     use M_anything, only : anyscalar_to_int64 !!     class(*),intent(in)  :: invalue !!     doubleprecision      :: invalue_local !!     doubleprecision      :: squarei !!        invalue_local=anyscalar_to_int64(invalue) !!        squarei=invalue_local*invalue_local !!     end function squarei !!     ! !!     end program demo_anyscalar_to_int64 !! !!   Results !! !!    16129.000000000000       127 \\ !!    16129 !!    1073676289.0000000       32767 \\ !!    1073676289 !!    4.6116860141324206E+018  2147483647 \\ !!    4611686014132420609 !!    8.5070591730234616E+037  9223372036854775807 \\ !!    85070591730234615847396907784232501249 !!    2.8948022309329049E+076 170141183460469231731687303715884105727 \\ !!    28948022309329048855892746252171976962977213799489202546401021394546514198529 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT impure elemental function anyscalar_to_int64 ( valuein ) result ( ii38 ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none ! ident_6=\"@(#)M_anything::anyscalar_to_int64(3f): convert integer parameter of any kind to 64-bit integer\" class ( * ), intent ( in ) :: valuein integer ( kind = int64 ) :: ii38 integer :: ios character ( len = 256 ) :: message select type ( valuein ) type is ( integer ( kind = int8 )); ii38 = int ( valuein , kind = int64 ) type is ( integer ( kind = int16 )); ii38 = int ( valuein , kind = int64 ) type is ( integer ( kind = int32 )); ii38 = valuein type is ( integer ( kind = int64 )); ii38 = valuein type is ( real ( kind = real32 )); ii38 = int ( valuein , kind = int64 ) type is ( real ( kind = real64 )); ii38 = int ( valuein , kind = int64 ) Type is ( real ( kind = real128 )); ii38 = int ( valuein , kind = int64 ) type is ( logical ); ii38 = merge ( 0_int64 , 1_int64 , valuein ) type is ( character ( len =* )) ; read ( valuein , * , iostat = ios , iomsg = message ) ii38 if ( ios . ne . 0 ) then write ( error_unit , * ) '*anyscalar_to_int64* ERROR: ' // trim ( message ) stop 2 endif class default write ( error_unit , * ) '*anyscalar_to_int64* ERROR: unknown integer type' stop 3 end select end function anyscalar_to_int64 !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !! !!    anyinteger_to_string(3f) - [M_anything] convert integer of any kind to a string !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    impure function anyinteger_to_string(intin) result(str) !! !!     character(len=:),allocatable :: anyinteger_to_string !!     class(*),intent(in)          :: intin !! !!##DESCRIPTION !! !!    Converts an integer value to a string representing the value. !!    This function allows arguments of different INTEGER types as input. !! !!##OPTIONS !! !!    VALUEIN  INTEGER input argument to be converted to a string. !!             May be of KIND kind=int8, kind=int16, kind=int32, kind=int64. !! !!##RESULTS !!             The value of VALUIN converted to a CHARACTER string. !! !!##EXAMPLE !! !! !!   Sample program !! !!    program demo_anyinteger_to_string !!    use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!    use M_anything, only : itoc=>anyinteger_to_string !!    implicit none !!       write(*,*)itoc(huge(0_int8)),       '=> 127' !!       write(*,*)itoc(huge(0_int16)),      '=> 32767' !!       write(*,*)itoc(huge(0_int32)),      '=> 2147483647' !!       write(*,*)itoc(huge(0_int64)),      '=> 9223372036854775807',huge(0_int64) !!       write(*,*)itoc(-(huge(0_int64)-1)), '=> -9223372036854775806' !!    end program demo_anyinteger_to_string !! !!   Results: !! !!    127=> 127 !!    32767=> 32767 !!    2147483647=> 2147483647 !!    9223372036854775807=> 9223372036854775807 !!    -9223372036854775806=> -9223372036854775806 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    MIT impure function anyinteger_to_string ( int ) result ( out ) use , intrinsic :: iso_fortran_env , only : int64 ! ident_7=\"@(#)M_anything::anyinteger_to_string(3f): function that converts an integer value to a character string\" class ( * ), intent ( in ) :: int character ( len = :), allocatable :: out integer , parameter :: maxlen = 32 ! assumed more than enough characters for largest input value integer :: i , k integer ( kind = int64 ) :: intval integer ( kind = int64 ) :: int_local integer :: str ( maxlen ) integer , parameter :: dig0 = ichar ( '0' ) integer , parameter :: minus = ichar ( '-' ) int_local = anyscalar_to_int64 ( int ) ! convert input to largest integer type intval = abs ( int_local ) do i = 1 , maxlen ! generate digits from smallest significant digit to largest str ( i ) = dig0 + mod ( intval , 10_int64 ) intval = intval / 10 if ( intval == 0 ) exit enddo if ( int_local < 0 ) then ! now make sure the sign is correct i = i + 1 str ( i ) = minus endif allocate ( character ( len = i ) :: out ) do k = i , 1 , - 1 ! have all the digits in reverse order, now flip them and convert to a string out ( i - k + 1 : i - k + 1 ) = char ( str ( k )) enddo end function anyinteger_to_string !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_anything !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","loc":"sourcefile/m_anything.f90.html"},{"title":"scalars.f90 – M_anything","text":"Contents Programs scalars Source Code scalars.f90 Source Code program scalars use M_anything , only : anyscalar_to_real use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none integer :: ios integer ( kind = int8 ) :: tiny = huge ( 0_int8 ) integer ( kind = int16 ) :: small = huge ( 0_int16 ) integer ( kind = int32 ) :: medium = huge ( 0_int32 ) integer ( kind = int64 ) :: large = huge ( 0_int64 ) real ( kind = real32 ) :: rs = huge ( 0.0_real32 ) real ( kind = real64 ) :: rm = huge ( 0.0_real64 ) real ( kind = real128 ) :: rl = huge ( 0.0_real128 ) 101 format ( a10 , \"|\" , i39 , \"|\" , i11 , \"|\" , i39 ) 102 format ( a10 , \"|\" , g0 , t55 , \"|\" , i11 , \"|\" , g0 ) write ( * , * ) 'First show the intrinsic variables of various KINDS we will be using' write ( * , * ) '  NAME   |VALUE                                  |KIND(VALUE)|10**RANGE(VALUE)' write ( * , 102 ) 'rs     ' , rs , kind ( rs ), 1 0.0_real32 ** range ( rs ) write ( * , 102 ) 'rm     ' , rm , kind ( rm ), 1 0.0_real64 ** range ( rm ) write ( * , 102 ) 'rl     ' , rl , kind ( rl ), 1 0.0_real128 ** range ( rl ) write ( * , 102 ) 'tiny   ' , tiny , kind ( tiny ) write ( * , 102 ) 'small  ' , small , kind ( small ) write ( * , 102 ) 'medium ' , medium , kind ( medium ) write ( * , 102 ) 'large  ' , large , kind ( large ) write ( * , * ) 'Test squarei with all INTEGER KINDs:' write ( * , * ) '(and given the following facts what is the expected output?)' write ( * , * ) 'FACTS:' write ( * , * ) '127 * 127 = 16129' write ( * , * ) '32767 * 32767 = 1073676289' write ( * , * ) '2147483647 * 2147483647 = 4611686014132420609' write ( * , * ) '9223372036854775807 * 9223372036854775807 = 85070591730234615847396907784232501249' write ( * , * ) '170141183460469231731687303715884105727 * 170141183460469231731687303715884105727 =& &28948022309329048855892746252171976962977213799489202546401021394546514198529' write ( * , * ) 'OUTPUT:' 202 format ( a , * ( g0 :, '; ' )) write ( * , 202 , iostat = ios ) 'SQUAREI()  :' , squarei ( tiny ), squarei ( small ), squarei ( medium ), squarei ( large ) write ( * , 202 , iostat = ios ) 'SQUAREI()  :' , squarei ( rs ), squarei ( rm ), squarei ( rl ) contains !! THIS FUNCTION CAN TAKE AN INTEGER OR REAL OF ANY TYPE KNOWN TO ANYSCALAR_TO_REAL() AS AN ARGUMENT function squarei ( invalue ) result ( dvalue ) ! square an integer value generically use M_anything , only : anyscalar_to_real implicit none class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue real , parameter :: biggest = sqrt ( real ( 0.0 , kind = real128 )) invalue_local = anyscalar_to_real ( invalue ) !if(invalue_local.gt.biggest)then !   write(*,*)'ERROR:*squarei* input value to big=',invalue_local !endif dvalue = invalue_local * invalue_local end function squarei end program scalars","tags":"","loc":"sourcefile/scalars.f90.html"},{"title":"demo_M_anything.f90 – M_anything","text":"Contents Programs demo_anyscalar_to_double Source Code demo_M_anything.f90 Source Code program demo_anyscalar_to_double use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squareall ( 2_int8 ) write ( * , * ) squareall ( 2_int16 ) write ( * , * ) squareall ( 2_int32 ) write ( * , * ) squareall ( 2_int64 ) write ( * , * ) squareall ( 2.0_real32 ) write ( * , * ) squareall ( 2.0_real64 ) write ( * , * ) squareall ( 2.0_real128 ) contains function squareall ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squareall end program demo_anyscalar_to_double","tags":"","loc":"sourcefile/demo_m_anything.f90.html"},{"title":"demo_anyscalar_to_real128.f90 – M_anything","text":"Contents Programs demo_anyscalar_to_real128 Source Code demo_anyscalar_to_real128.f90 Source Code program demo_anyscalar_to_real128 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2_int8 ) write ( * , * ) squarei ( 2_int16 ) write ( * , * ) squarei ( 2_int32 ) write ( * , * ) squarei ( 2_int64 ) write ( * , * ) squarei ( 2.0_real32 ) write ( * , * ) squarei ( 2.0_real64 ) write ( * , * ) squarei ( 2.0_real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real128 class ( * ), intent ( in ) :: invalue real ( kind = real128 ) :: invalue_local real ( kind = real128 ) :: dvalue invalue_local = anyscalar_to_real128 ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_real128","tags":"","loc":"sourcefile/demo_anyscalar_to_real128.f90.html"},{"title":"demo_empty.f90 – M_anything","text":"Contents Programs demo_empty_ Source Code demo_empty.f90 Source Code program demo_empty_ use M_anything , only : empty , assignment ( = ) integer , allocatable :: ints (:) character (:), allocatable :: strs (:) real , allocatable :: reals (:) ints = empty write ( * , * ) size ( ints ) write ( * , * ) 'give them some size ...' reals = [ 1.0 , 2.0 , 3.0 ] ints = [ 1 , 2 , 3 ] strs = [ character ( len = 10 ) :: \"one\" , \"two\" , \"three\" , \"four\" ] write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) ints = empty reals = empty strs = empty write ( * , * ) 'back to empty ...' write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) end program demo_empty_","tags":"","loc":"sourcefile/demo_empty.f90.html"},{"title":"demo_anyscalar_to_int64.f90 – M_anything","text":"Contents Programs demo_anyscalar_to_int64 Source Code demo_anyscalar_to_int64.f90 Source Code program demo_anyscalar_to_int64 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( huge ( 0_int8 )), huge ( 0_int8 ) , & & '16129' write ( * , * ) squarei ( huge ( 0_int16 )), huge ( 0_int16 ) , & & '1073676289' write ( * , * ) squarei ( huge ( 0_int32 )), huge ( 0_int32 ) , & & '4611686014132420609' write ( * , * ) squarei ( huge ( 0_int64 )), huge ( 0_int64 ) , & & '85070591730234615847396907784232501249' contains ! function squarei ( invalue ) use M_anything , only : anyscalar_to_int64 class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: squarei invalue_local = anyscalar_to_int64 ( invalue ) squarei = invalue_local * invalue_local end function squarei ! end program demo_anyscalar_to_int64","tags":"","loc":"sourcefile/demo_anyscalar_to_int64.f90.html"},{"title":"demo_anyscalar_to_double.f90 – M_anything","text":"Contents Programs demo_anyscalar_to_double Source Code demo_anyscalar_to_double.f90 Source Code program demo_anyscalar_to_double use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2_int8 ) write ( * , * ) squarei ( 2_int16 ) write ( * , * ) squarei ( 2_int32 ) write ( * , * ) squarei ( 2_int64 ) write ( * , * ) squarei ( 2.0_real32 ) write ( * , * ) squarei ( 2.0_real64 ) write ( * , * ) squarei ( 2.0_real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_double","tags":"","loc":"sourcefile/demo_anyscalar_to_double.f90.html"},{"title":"demo_anything_to_bytes.f90 – M_anything","text":"Contents Programs demo_anything_to_bytes Source Code demo_anything_to_bytes.f90 Source Code program demo_anything_to_bytes use M_anything , only : anything_to_bytes !!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!use, intrinsic :: iso_fortran_env, only : real32, real64, real128 implicit none integer :: i write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ([( i * i , i = 1 , 10 )]) write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ([ 1 1.11 , 2 2.22 , 3 3.33 ]) write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ( 'This is a string' ) end program demo_anything_to_bytes","tags":"","loc":"sourcefile/demo_anything_to_bytes.f90.html"},{"title":"demo_anyinteger_to_string.f90 – M_anything","text":"Contents Programs demo_anyinteger_to_string Source Code demo_anyinteger_to_string.f90 Source Code program demo_anyinteger_to_string use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use M_anything , only : itoc => anyinteger_to_string implicit none write ( * , * ) itoc ( huge ( 0_int8 )), '=> 127' write ( * , * ) itoc ( huge ( 0_int16 )), '=> 32767' write ( * , * ) itoc ( huge ( 0_int32 )), '=> 2147483647' write ( * , * ) itoc ( huge ( 0_int64 )), '=> 9223372036854775807' , huge ( 0_int64 ) write ( * , * ) itoc ( - ( huge ( 0_int64 ) - 1 )), '=> -9223372036854775806' end program demo_anyinteger_to_string","tags":"","loc":"sourcefile/demo_anyinteger_to_string.f90.html"},{"title":"demo_anyscalar_to_real.f90 – M_anything","text":"Contents Programs demo_anyscalar_to_real Source Code demo_anyscalar_to_real.f90 Source Code program demo_anyscalar_to_real use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2_int8 ) write ( * , * ) squarei ( 2_int16 ) write ( * , * ) squarei ( 2_int32 ) write ( * , * ) squarei ( 2_int64 ) write ( * , * ) squarei ( 2.0_real32 ) write ( * , * ) squarei ( 2.0_real64 ) write ( * , * ) squarei ( 2.0_real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue invalue_local = anyscalar_to_real ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_real","tags":"","loc":"sourcefile/demo_anyscalar_to_real.f90.html"},{"title":"test_suite_M_anything.f90 – M_anything","text":"Contents Programs runtest Modules M_test_suite_M_anything Source Code test_suite_M_anything.f90 Source Code module M_test_suite_M_anything use , intrinsic :: ISO_FORTRAN_ENV , only : INT8 , INT16 , INT32 , INT64 !  1           2           4           8 use , intrinsic :: ISO_FORTRAN_ENV , only : REAL32 , REAL64 , REAL128 !  4           8          10 use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level use M_anything , only : anyinteger_to_string , anyscalar_to_int64 use M_anything , only : anyscalar_to_real , anyscalar_to_double , anyscalar_to_real128 use M_anything , only : anything_to_bytes , bytes_to_anything use M_anything , only : empty , assignment ( = ) private public test_suite_M_anything contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine test_suite_M_anything () use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_level !! setup call test_anyscalar_to_int64 () call test_anyinteger_to_string () call test_anyscalar_to_real () call test_anyscalar_to_double () call test_anything_to_bytes () call test_empty () !!teardown contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_int64 () call unit_check_start ( 'anyscalar_to_int64' , msg = '' ) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int8 )) . eq . 127_int64 , huge ( 0_int8 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int16 )). eq . 32767_int64 , huge ( 0_int16 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int32 )). eq . 2147483647_int64 , huge ( 0_int32 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int64 )). eq . 9223372036854775807_int64 , huge ( 0_int64 )) call unit_check_done ( 'anyscalar_to_int64' , msg = '' ) end subroutine test_anyscalar_to_int64 !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyinteger_to_string () call unit_check_start ( 'anyinteger_to_string' , msg = '' ) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int8 )) . eq . '127' , huge ( 0_int8 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int16 )). eq . '32767' , huge ( 0_int16 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int32 )). eq . '2147483647' , huge ( 0_int32 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int64 )). eq . '9223372036854775807' , huge ( 0_int64 )) call unit_check_done ( 'anyinteger_to_string' , msg = '' ) end subroutine test_anyinteger_to_string !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_double () real :: infinity !!character(len=*),parameter :: line='infinity' character ( len = 8 ) :: line = 'infinity' read ( line , * ) infinity call unit_check_start ( 'anyscalar_to_double' , msg = '' ) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int8 )) . eq . huge ( 0_int8 ), huge ( 0_int8 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int16 )) . eq . huge ( 0_int16 ), huge ( 0_int16 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int32 )) . eq . huge ( 0_int32 ), huge ( 0_int32 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int64 )) . eq . huge ( 0_int64 ), huge ( 0_int64 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real32 )) . eq . huge ( 0.0_real32 ), huge ( 0.0_real32 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real64 )) . eq . huge ( 0.0_real64 ), huge ( 0.0_real64 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real128 )) . eq . infinity , huge ( 0.0_real128 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( 123 4.0_real128 ) . eq . 123 4.0_real128 , 123 4.0_real128 ) call unit_check_done ( 'anyscalar_to_double' , msg = '' ) end subroutine test_anyscalar_to_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_real () real :: infinity !!character(len=*),parameter :: line='infinity' character ( len = 8 ) :: line = 'infinity' read ( line , * ) infinity call unit_check_start ( 'anyscalar_to_real' , msg = '' ) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int8 )) . eq . real ( huge ( 0_int8 )), huge ( 0_int8 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int16 )) . eq . real ( huge ( 0_int16 )), huge ( 0_int16 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int32 )) . eq . real ( huge ( 0_int32 )), huge ( 0_int32 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int64 )) . eq . real ( huge ( 0_int64 )), huge ( 0_int64 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real32 )) . eq . real ( huge ( 0.0_real32 )), huge ( 0.0_real32 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real64 )) . eq . infinity , huge ( 0.0_real64 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real128 )). eq . infinity , huge ( 0.0_real128 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( 123 4.0_real64 ) . eq . 123 4.0_real64 , 123 4.0_real64 ) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( 123 4.0_real128 ) . eq . 123 4.0_real128 , 123 4.0_real128 ) call unit_check_done ( 'anyscalar_to_real' , msg = '' ) end subroutine test_anyscalar_to_real !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anything_to_bytes () call unit_check_start ( 'anything_to_bytes' , msg = '' ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int8 )) . eq . transfer ( huge ( 0_int8 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int16 )) . eq . transfer ( huge ( 0_int16 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int32 )) . eq . transfer ( huge ( 0_int32 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int64 )) . eq . transfer ( huge ( 0_int64 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real32 )) . eq . transfer ( huge ( 0.0_real32 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real64 )) . eq . transfer ( huge ( 0.0_real64 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real128 )) . eq . transfer ( huge ( 0.0_real128 ), 'A' )) ) call unit_check_done ( 'anything_to_bytes' , msg = '' ) end subroutine test_anything_to_bytes !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_empty !!use M_anything, only : empty, assignment(=) implicit none doubleprecision , allocatable :: d (:) integer , allocatable :: i (:) real , allocatable :: r (:) character ( len = :), allocatable :: c (:) integer , allocatable :: ints (:) character (:), allocatable :: strs (:) integer :: answer call unit_check_start ( 'empty' ) !  register an entry for specified name in database with status of zero (0) d = empty r = empty i = empty c = empty call unit_check ( 'empty' , size ( d ). eq . 0 , 'checking double' ) call unit_check ( 'empty' , size ( r ). eq . 0 , 'checking real' ) call unit_check ( 'empty' , size ( i ). eq . 0 , 'checking integer' ) call unit_check ( 'empty' , size ( c ). eq . 0 , 'checking character' ) ints = empty answer = 0 call check_ints ( answer , ints ) ints = [ 1 , 2 , 3 ] answer = 3 call check_ints ( answer , ints ) call unit_check ( 'empty' , all ( ints . eq .[ 1 , 2 , 3 ]), msg = 'normal allocation' ) ints = empty answer = 0 call check_ints ( answer , ints ) strs = empty answer = 0 call check_strs ( answer , strs ) strs = [ \"apple\" , \"orang\" , \"banan\" ] answer = 3 call check_strs ( answer , strs ) call unit_check ( 'empty' , all ( strs . eq .[ \"apple\" , \"orang\" , \"banan\" ]), msg = 'normal allocation' ) strs = empty answer = 0 call check_strs ( answer , strs ) call unit_check_done ( 'empty' ) end subroutine test_empty !----------------------------------------------------------------------------------------------------------------------------------- subroutine check_ints ( answer , ints ) integer , intent ( in ), allocatable :: ints (:) integer , intent ( in ) :: answer !  if mask test fails, change database status for specified entry to -1 and stop program, else continue if ( allocated ( ints )) then call unit_check ( 'empty' , size ( ints ). eq . answer , 'size is' , answer ) endif end subroutine check_ints !----------------------------------------------------------------------------------------------------------------------------------- subroutine check_strs ( answer , strs ) integer , intent ( in ) :: answer character ( len = :), allocatable , intent ( in ) :: strs (:) integer k if ( allocated ( strs ) ) then if ( unit_check_level . gt . 0 ) then print * , \"strs: val = \" , ( strs ( k ) // \" \" , k = 1 , size ( strs ) ) print * , \"      len_elem = \" , len ( strs ( 1 )) endif call unit_check ( 'empty' , size ( strs ). eq . answer , 'size is' , answer ) endif end subroutine check_strs !----------------------------------------------------------------------------------------------------------------------------------- end subroutine test_suite_M_anything !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== end module M_test_suite_M_anything !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! program runtest use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level , unit_check_stop use M_test_suite_M_anything implicit none unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_anything () call unit_check_stop () end program runtest !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================!","tags":"","loc":"sourcefile/test_suite_m_anything.f90.html"},{"title":"anyinteger_to_string – M_anything","text":"public impure function anyinteger_to_string(int) result(out) Uses iso_fortran_env NAME anyinteger_to_string ( 3 f ) - [ M_anything ] convert integer of any kind to a string ( LICENSE : MIT ) SYNOPSIS impure function anyinteger_to_string(intin) result(str)\n\n character(len=:),allocatable :: anyinteger_to_string\n class(*),intent(in)          :: intin DESCRIPTION Converts an integer value to a string representing the value.\nThis function allows arguments of different INTEGER types as input. OPTIONS VALUEIN  INTEGER input argument to be converted to a string.\n         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64. RESULTS The value of VALUIN converted to a CHARACTER string. EXAMPLE Sample program program demo_anyinteger_to_string use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use M_anything , only : itoc => anyinteger_to_string implicit none write ( * , * ) itoc ( huge ( 0 _int8 )) , ' => 127 ' write ( * , * ) itoc ( huge ( 0 _int16 )) , ' => 32767 ' write ( * , * ) itoc ( huge ( 0 _int32 )) , ' => 2147483647 ' write ( * , * ) itoc ( huge ( 0 _int64 )) , ' => 9223372036854775807 ' , huge ( 0 _int64 ) write ( * , * ) itoc ( - ( huge ( 0 _int64 ) - 1 )) , ' => -9223372036854775806 ' end program demo_anyinteger_to_string Results: 127 => 127 32767 => 32767 2147483647 => 2147483647 9223372036854775807 => 9223372036854775807 - 9223372036854775806 => - 9223372036854775806 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name class(*), intent(in) :: int Return Value character(len=:),allocatable Contents Source Code anyinteger_to_string Source Code impure function anyinteger_to_string ( int ) result ( out ) use , intrinsic :: iso_fortran_env , only : int64 ! ident_7=\"@(#)M_anything::anyinteger_to_string(3f): function that converts an integer value to a character string\" class ( * ), intent ( in ) :: int character ( len = :), allocatable :: out integer , parameter :: maxlen = 32 ! assumed more than enough characters for largest input value integer :: i , k integer ( kind = int64 ) :: intval integer ( kind = int64 ) :: int_local integer :: str ( maxlen ) integer , parameter :: dig0 = ichar ( '0' ) integer , parameter :: minus = ichar ( '-' ) int_local = anyscalar_to_int64 ( int ) ! convert input to largest integer type intval = abs ( int_local ) do i = 1 , maxlen ! generate digits from smallest significant digit to largest str ( i ) = dig0 + mod ( intval , 10_int64 ) intval = intval / 10 if ( intval == 0 ) exit enddo if ( int_local < 0 ) then ! now make sure the sign is correct i = i + 1 str ( i ) = minus endif allocate ( character ( len = i ) :: out ) do k = i , 1 , - 1 ! have all the digits in reverse order, now flip them and convert to a string out ( i - k + 1 : i - k + 1 ) = char ( str ( k )) enddo end function anyinteger_to_string","tags":"","loc":"proc/anyinteger_to_string.html"},{"title":"anyscalar_to_double – M_anything","text":"public pure elemental function anyscalar_to_double(valuein) result(d_out) Uses iso_fortran_env NAME anyscalar_to_double ( 3 f ) - [ M_anything ] convert integer or real parameter of any kind to doubleprecision ( LICENSE : MIT ) SYNOPSIS pure elemental function anyscalar_to_double(valuein) result(d_out)\n\n class(*),intent(in)  :: valuein\n doubleprecision      :: d_out DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used to create other procedures that can take many\nscalar arguments as input options. OPTIONS VALUEIN  input argument of a procedure to convert to type DOUBLEPRECISION.\n         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64,\n         kind=real32, kind=real64, or kind=real128 RESULTS D_OUT    The value of VALUIN converted to doubleprecision (assuming\n         it is actually in the range of type DOUBLEPRECISION). EXAMPLE Sample program program demo_anyscalar_to_double use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2 _int8 ) write ( * , * ) squarei ( 2 _int16 ) write ( * , * ) squarei ( 2 _int32 ) write ( * , * ) squarei ( 2 _int64 ) write ( * , * ) squarei ( 2 . 0 _real32 ) write ( * , * ) squarei ( 2 . 0 _real64 ) write ( * , * ) squarei ( 2 . 0 _real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ) , intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_double AUTHOR John S. Urban LICENSE MIT ,input_unit,output_unit\nif(valuein.gt.big)then\n   write(error_unit, )’ anyscalar_to_double value too large ‘,valuein\nendif\nstop ‘ M_anything::anyscalar_to_double: unknown type’ Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value doubleprecision Contents Source Code anyscalar_to_double Source Code pure elemental function anyscalar_to_double ( valuein ) result ( d_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none ! ident_4=\"@(#)M_anything::anyscalar_to_double(3f): convert integer or real parameter of any kind to doubleprecision\" class ( * ), intent ( in ) :: valuein doubleprecision :: d_out doubleprecision , parameter :: big = huge ( 0.0d0 ) select type ( valuein ) type is ( integer ( kind = int8 )); d_out = dble ( valuein ) type is ( integer ( kind = int16 )); d_out = dble ( valuein ) type is ( integer ( kind = int32 )); d_out = dble ( valuein ) type is ( integer ( kind = int64 )); d_out = dble ( valuein ) type is ( real ( kind = real32 )); d_out = dble ( valuein ) type is ( real ( kind = real64 )); d_out = dble ( valuein ) Type is ( real ( kind = real128 )) !!if(valuein.gt.big)then !!   write(error_unit,*)'*anyscalar_to_double* value too large ',valuein !!endif d_out = dble ( valuein ) type is ( logical ); d_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out !type is (real(kind=real128)) !   if(valuein.gt.big)then !      write(error_unit,*)'*anyscalar_to_double* value too large ',valuein !   endif !   d_out=dble(valuein) class default d_out = 0.0d0 !!stop '*M_anything::anyscalar_to_double: unknown type' end select end function anyscalar_to_double","tags":"","loc":"proc/anyscalar_to_double.html"},{"title":"anyscalar_to_int64 – M_anything","text":"public impure elemental function anyscalar_to_int64(valuein) result(ii38) Uses iso_fortran_env NAME anyscalar_to_int64 ( 3 f ) - [ M_anything ] convert integer any kind to integer ( kind = int64 ) ( LICENSE : MIT ) SYNOPSIS impure elemental function anyscalar_to_int64(intin) result(value)\n\n class(*),intent(in) :: intin\n integer(kind=int64) :: value DESCRIPTION This function uses polymorphism to allow arguments of different INTEGER types\nas input. It is typically used to create other procedures that can take\nmany scalar arguments as input options, equivalent to passing the\nparameter VALUE as int(VALUE,0_int64). OPTIONS VALUEIN  input argument of a procedure to convert to type INTEGER(KIND=int64).\n         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64. RESULTS The value of VALUIN converted to INTEGER(KIND=INT64). EXAMPLE Sample program program demo_anyscalar_to_int64 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( huge ( 0 _int8 )) , huge ( 0 _int8 ) , & & ' 16129 ' write ( * , * ) squarei ( huge ( 0 _int16 )) , huge ( 0 _int16 ) , & & ' 1073676289 ' write ( * , * ) squarei ( huge ( 0 _int32 )) , huge ( 0 _int32 ) , & & ' 4611686014132420609 ' write ( * , * ) squarei ( huge ( 0 _int64 )) , huge ( 0 _int64 ) , & & ' 85070591730234615847396907784232501249 ' contains ! function squarei ( invalue ) use M_anything , only : anyscalar_to_int64 class ( * ) , intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: squarei invalue_local = anyscalar_to_int64 ( invalue ) squarei = invalue_local * invalue_local end function squarei ! end program demo_anyscalar_to_int64 Results 16129.000000000000 127 \\ 16129 1073676289.0000000 32767 \\ 1073676289 4.6116860141324206E+018 2147483647 \\ 4611686014132420609 8.5070591730234616E+037 9223372036854775807 \\ 85070591730234615847396907784232501249 2.8948022309329049E+076 170141183460469231731687303715884105727 \\ 28948022309329048855892746252171976962977213799489202546401021394546514198529 AUTHOR John S. Urban LICENSE MIT ,input_unit,output_unit Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value integer(kind=int64) Contents Source Code anyscalar_to_int64 Source Code impure elemental function anyscalar_to_int64 ( valuein ) result ( ii38 ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none ! ident_6=\"@(#)M_anything::anyscalar_to_int64(3f): convert integer parameter of any kind to 64-bit integer\" class ( * ), intent ( in ) :: valuein integer ( kind = int64 ) :: ii38 integer :: ios character ( len = 256 ) :: message select type ( valuein ) type is ( integer ( kind = int8 )); ii38 = int ( valuein , kind = int64 ) type is ( integer ( kind = int16 )); ii38 = int ( valuein , kind = int64 ) type is ( integer ( kind = int32 )); ii38 = valuein type is ( integer ( kind = int64 )); ii38 = valuein type is ( real ( kind = real32 )); ii38 = int ( valuein , kind = int64 ) type is ( real ( kind = real64 )); ii38 = int ( valuein , kind = int64 ) Type is ( real ( kind = real128 )); ii38 = int ( valuein , kind = int64 ) type is ( logical ); ii38 = merge ( 0_int64 , 1_int64 , valuein ) type is ( character ( len =* )) ; read ( valuein , * , iostat = ios , iomsg = message ) ii38 if ( ios . ne . 0 ) then write ( error_unit , * ) '*anyscalar_to_int64* ERROR: ' // trim ( message ) stop 2 endif class default write ( error_unit , * ) '*anyscalar_to_int64* ERROR: unknown integer type' stop 3 end select end function anyscalar_to_int64","tags":"","loc":"proc/anyscalar_to_int64.html"},{"title":"anyscalar_to_real – M_anything","text":"public pure elemental function anyscalar_to_real(valuein) result(r_out) Uses iso_fortran_env NAME anyscalar_to_real ( 3 f ) - [ M_anything ] convert integer or real parameter of any kind to real ( LICENSE : MIT ) SYNOPSIS pure elemental function anyscalar_to_real(valuein) result(r_out)\n\n class(*),intent(in)  :: valuein\n real                 :: r_out DESCRIPTION This function uses polymorphism to allow input arguments of different types.\nIt is used to create other procedures that can take\nmany scalar arguments as input options. OPTIONS VALUEIN  input argument of a procedure to convert to type REAL.\n         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64,\n         kind=real32, kind=real64, or kind=real128. RESULTS R_OUT    The value of VALUIN converted to real (assuming it is actually\n         in the range of type REAL). EXAMPLE Sample program program demo_anyscalar_to_real use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2 _int8 ) write ( * , * ) squarei ( 2 _int16 ) write ( * , * ) squarei ( 2 _int32 ) write ( * , * ) squarei ( 2 _int64 ) write ( * , * ) squarei ( 2 . 0 _real32 ) write ( * , * ) squarei ( 2 . 0 _real64 ) write ( * , * ) squarei ( 2 . 0 _real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real class ( * ) , intent ( in ) :: invalue real :: invalue_local real :: dvalue invalue_local = anyscalar_to_real ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_real AUTHOR John S. Urban LICENSE MIT ,input_unit,output_unit\nif(valuein.gt.big)then\n   write(error_unit, )’ anyscalar_to_real value too large ‘,valuein\nendif\nif(valuein.gt.big)then\n   write(error_unit, )’ anyscalar_to_real value too large ‘,valuein\nendif Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value real Contents Source Code anyscalar_to_real Source Code pure elemental function anyscalar_to_real ( valuein ) result ( r_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none ! ident_5=\"@(#)M_anything::anyscalar_to_real(3f): convert integer or real parameter of any kind to real\" class ( * ), intent ( in ) :: valuein real :: r_out real , parameter :: big = huge ( 0.0 ) select type ( valuein ) type is ( integer ( kind = int8 )); r_out = real ( valuein ) type is ( integer ( kind = int16 )); r_out = real ( valuein ) type is ( integer ( kind = int32 )); r_out = real ( valuein ) type is ( integer ( kind = int64 )); r_out = real ( valuein ) type is ( real ( kind = real32 )); r_out = real ( valuein ) type is ( real ( kind = real64 )) !!if(valuein.gt.big)then !!   write(error_unit,*)'*anyscalar_to_real* value too large ',valuein !!endif r_out = real ( valuein ) type is ( real ( kind = real128 )) !!if(valuein.gt.big)then !!   write(error_unit,*)'*anyscalar_to_real* value too large ',valuein !!endif r_out = real ( valuein ) type is ( logical ); r_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) r_out !type is (real(kind=real128));  r_out=real(valuein) end select end function anyscalar_to_real","tags":"","loc":"proc/anyscalar_to_real.html"},{"title":"anyscalar_to_real128 – M_anything","text":"public pure elemental function anyscalar_to_real128(valuein) result(d_out) Uses iso_fortran_env NAME anyscalar_to_real128 ( 3 f ) - [ M_anything ] convert integer or real parameter of any kind to real128 ( LICENSE : MIT ) SYNOPSIS pure elemental function anyscalar_to_real128(valuein) result(d_out)\n\n class(*),intent(in) :: valuein\n real(kind=128)      :: d_out DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used to create other procedures that can take many\nscalar arguments as input options. OPTIONS VALUEIN  input argument of a procedure to convert to type REAL128.\n         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64,\n         kind=real32, kind=real64, or kind=real128 RESULTS D_OUT    The value of VALUIN converted to REAL128 (assuming\n         it is actually in the range of type REAL128). EXAMPLE Sample program program demo_anyscalar_to_real128 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2 _int8 ) write ( * , * ) squarei ( 2 _int16 ) write ( * , * ) squarei ( 2 _int32 ) write ( * , * ) squarei ( 2 _int64 ) write ( * , * ) squarei ( 2 . 0 _real32 ) write ( * , * ) squarei ( 2 . 0 _real64 ) write ( * , * ) squarei ( 2 . 0 _real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real128 class ( * ) , intent ( in ) :: invalue real ( kind = real128 ) :: invalue_local real ( kind = real128 ) :: dvalue invalue_local = anyscalar_to_real128 ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_real128 AUTHOR John S. Urban LICENSE MIT ,input_unit,output_unit\nd_out=huge(0.0_real128)\nstop ‘*M_anything::anyscalar_to_real128: unknown type’ Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value real(kind=real128) Contents Source Code anyscalar_to_real128 Source Code pure elemental function anyscalar_to_real128 ( valuein ) result ( d_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none ! ident_3=\"@(#)M_anything::anyscalar_to_real128(3f): convert integer or real parameter of any kind to real128\" class ( * ), intent ( in ) :: valuein real ( kind = real128 ) :: d_out character ( len = 3 ) :: readable select type ( valuein ) type is ( integer ( kind = int8 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int16 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int32 )); d_out = real ( valuein , kind = real128 ) type is ( integer ( kind = int64 )); d_out = real ( valuein , kind = real128 ) type is ( real ( kind = real32 )); d_out = real ( valuein , kind = real128 ) type is ( real ( kind = real64 )); d_out = real ( valuein , kind = real128 ) Type is ( real ( kind = real128 )); d_out = valuein type is ( logical ); d_out = merge ( 0.0_real128 , 1.0_real128 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out class default !!d_out=huge(0.0_real128) readable = 'NaN' read ( readable , * ) d_out !!stop '*M_anything::anyscalar_to_real128: unknown type' end select end function anyscalar_to_real128","tags":"","loc":"proc/anyscalar_to_real128.html"},{"title":"bytes_to_anything – M_anything","text":"public subroutine bytes_to_anything(chars, anything) NAME bytes_to_anything ( 3 f ) - [ M_anything ] convert bytes ( character ) len = 1 ) :: array ( : )) to standard types ( LICENSE : MIT ) SYNOPSIS subroutine bytes_to_anything(chars,anything) character(len=1),allocatable :: chars(:)\nclass(*) :: anything DESCRIPTION This function uses polymorphism to allow input arguments of different\ntypes. It is used to create other procedures that can take many\nargument types as input options and convert them to a single type\nto simplify storing arbitrary data, to simplify generating data\nhashes, ... OPTIONS CHARS     The input value is an array of bytes (character(len=1)). RETURN ANYTHING  May be of KIND INTEGER(kind=int8), INTEGER(kind=int16),\n          INTEGER(kind=int32), INTEGER(kind=int64),\n          REAL(kind=real32, REAL(kind=real64),\n          REAL(kind=real128), complex, or CHARACTER(len=*) EXAMPLE Sample program Expected output AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=1), allocatable :: chars (:) class(*) :: anything Contents Source Code bytes_to_anything Source Code subroutine bytes_to_anything ( chars , anything ) character ( len = 1 ), allocatable :: chars (:) class ( * ) :: anything select type ( anything ) type is ( character ( len =* )); anything = transfer ( chars , anything ) type is ( complex ); anything = transfer ( chars , anything ) type is ( complex ( kind = dp )); anything = transfer ( chars , anything ) type is ( integer ( kind = int8 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int16 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int32 )); anything = transfer ( chars , anything ) type is ( integer ( kind = int64 )); anything = transfer ( chars , anything ) type is ( real ( kind = real32 )); anything = transfer ( chars , anything ) type is ( real ( kind = real64 )); anything = transfer ( chars , anything ) type is ( real ( kind = real128 )); anything = transfer ( chars , anything ) type is ( logical ); anything = transfer ( chars , anything ) class default stop 'crud. bytes_to_anything(1) does not know about this type' end select end subroutine bytes_to_anything","tags":"","loc":"proc/bytes_to_anything.html"},{"title":"anything_to_bytes – M_anything","text":"public interface anything_to_bytes Contents Module Procedures anything_to_bytes_arr anything_to_bytes_scalar Module Procedures private function anything_to_bytes_arr(anything) result(chars) Sample program Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) Return Value character(len=1),allocatable, (:) private function anything_to_bytes_scalar(anything) result(chars) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything Return Value character(len=1),allocatable, (:)","tags":"","loc":"interface/anything_to_bytes.html"},{"title":"assignment(=) – M_anything","text":"public interface assignment(=) Contents Module Procedures ints_empty_ reals_empty_ doubles_empty_ strings_empty_ Module Procedures private subroutine ints_empty_(x, emp) Sample program: Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private subroutine reals_empty_(x, emp) Arguments Type Intent Optional Attributes Name real, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private subroutine doubles_empty_(x, emp) Arguments Type Intent Optional Attributes Name doubleprecision, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private subroutine strings_empty_(x, emp) Arguments Type Intent Optional Attributes Name character, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp","tags":"","loc":"interface/assignment(=).html"},{"title":"squarei – M_anything","text":"function squarei(invalue) result(dvalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value real Contents Variables biggest invalue_local Source Code squarei Variables Type Visibility Attributes Name Initial real, public, parameter :: biggest = sqrt(real(0.0, kind=real128)) real, public :: invalue_local Source Code function squarei ( invalue ) result ( dvalue ) ! square an integer value generically use M_anything , only : anyscalar_to_real implicit none class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue real , parameter :: biggest = sqrt ( real ( 0.0 , kind = real128 )) invalue_local = anyscalar_to_real ( invalue ) !if(invalue_local.gt.biggest)then !   write(*,*)'ERROR:*squarei* input value to big=',invalue_local !endif dvalue = invalue_local * invalue_local end function squarei","tags":"","loc":"proc/squarei.html"},{"title":"squareall – M_anything","text":"function squareall(invalue) result(dvalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Contents Variables invalue_local Source Code squareall Variables Type Visibility Attributes Name Initial doubleprecision, public :: invalue_local Source Code function squareall ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squareall","tags":"","loc":"proc/squareall.html"},{"title":"squarei – M_anything","text":"function squarei(invalue) result(dvalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value real(kind=real128) Contents Variables invalue_local Source Code squarei Variables Type Visibility Attributes Name Initial real(kind=real128), public :: invalue_local Source Code function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real128 class ( * ), intent ( in ) :: invalue real ( kind = real128 ) :: invalue_local real ( kind = real128 ) :: dvalue invalue_local = anyscalar_to_real128 ( invalue ) dvalue = invalue_local * invalue_local end function squarei","tags":"","loc":"proc/squarei~2.html"},{"title":"squarei – M_anything","text":"function squarei(invalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Contents Variables invalue_local Source Code squarei Variables Type Visibility Attributes Name Initial doubleprecision, public :: invalue_local Source Code function squarei ( invalue ) use M_anything , only : anyscalar_to_int64 class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: squarei invalue_local = anyscalar_to_int64 ( invalue ) squarei = invalue_local * invalue_local end function squarei","tags":"","loc":"proc/squarei~3.html"},{"title":"squarei – M_anything","text":"function squarei(invalue) result(dvalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Contents Variables invalue_local Source Code squarei Variables Type Visibility Attributes Name Initial doubleprecision, public :: invalue_local Source Code function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squarei","tags":"","loc":"proc/squarei~4.html"},{"title":"squarei – M_anything","text":"function squarei(invalue) result(dvalue) Uses M_anything Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value real Contents Variables invalue_local Source Code squarei Variables Type Visibility Attributes Name Initial real, public :: invalue_local Source Code function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue invalue_local = anyscalar_to_real ( invalue ) dvalue = invalue_local * invalue_local end function squarei","tags":"","loc":"proc/squarei~5.html"},{"title":"test_suite_M_anything – M_anything","text":"public subroutine test_suite_M_anything() Uses M_verify setup\nteardown Arguments None Contents Source Code test_suite_M_anything Source Code subroutine test_suite_M_anything () use M_verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_verify , only : unit_check_level !! setup call test_anyscalar_to_int64 () call test_anyinteger_to_string () call test_anyscalar_to_real () call test_anyscalar_to_double () call test_anything_to_bytes () call test_empty () !!teardown contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_int64 () call unit_check_start ( 'anyscalar_to_int64' , msg = '' ) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int8 )) . eq . 127_int64 , huge ( 0_int8 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int16 )). eq . 32767_int64 , huge ( 0_int16 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int32 )). eq . 2147483647_int64 , huge ( 0_int32 )) call unit_check ( 'anyscalar_to_int64' , anyscalar_to_int64 ( huge ( 0_int64 )). eq . 9223372036854775807_int64 , huge ( 0_int64 )) call unit_check_done ( 'anyscalar_to_int64' , msg = '' ) end subroutine test_anyscalar_to_int64 !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyinteger_to_string () call unit_check_start ( 'anyinteger_to_string' , msg = '' ) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int8 )) . eq . '127' , huge ( 0_int8 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int16 )). eq . '32767' , huge ( 0_int16 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int32 )). eq . '2147483647' , huge ( 0_int32 )) call unit_check ( 'anyinteger_to_string' , anyinteger_to_string ( huge ( 0_int64 )). eq . '9223372036854775807' , huge ( 0_int64 )) call unit_check_done ( 'anyinteger_to_string' , msg = '' ) end subroutine test_anyinteger_to_string !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_double () real :: infinity !!character(len=*),parameter :: line='infinity' character ( len = 8 ) :: line = 'infinity' read ( line , * ) infinity call unit_check_start ( 'anyscalar_to_double' , msg = '' ) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int8 )) . eq . huge ( 0_int8 ), huge ( 0_int8 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int16 )) . eq . huge ( 0_int16 ), huge ( 0_int16 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int32 )) . eq . huge ( 0_int32 ), huge ( 0_int32 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0_int64 )) . eq . huge ( 0_int64 ), huge ( 0_int64 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real32 )) . eq . huge ( 0.0_real32 ), huge ( 0.0_real32 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real64 )) . eq . huge ( 0.0_real64 ), huge ( 0.0_real64 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( huge ( 0.0_real128 )) . eq . infinity , huge ( 0.0_real128 )) call unit_check ( 'anyscalar_to_double' , anyscalar_to_double ( 123 4.0_real128 ) . eq . 123 4.0_real128 , 123 4.0_real128 ) call unit_check_done ( 'anyscalar_to_double' , msg = '' ) end subroutine test_anyscalar_to_double !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anyscalar_to_real () real :: infinity !!character(len=*),parameter :: line='infinity' character ( len = 8 ) :: line = 'infinity' read ( line , * ) infinity call unit_check_start ( 'anyscalar_to_real' , msg = '' ) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int8 )) . eq . real ( huge ( 0_int8 )), huge ( 0_int8 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int16 )) . eq . real ( huge ( 0_int16 )), huge ( 0_int16 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int32 )) . eq . real ( huge ( 0_int32 )), huge ( 0_int32 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0_int64 )) . eq . real ( huge ( 0_int64 )), huge ( 0_int64 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real32 )) . eq . real ( huge ( 0.0_real32 )), huge ( 0.0_real32 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real64 )) . eq . infinity , huge ( 0.0_real64 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( huge ( 0.0_real128 )). eq . infinity , huge ( 0.0_real128 )) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( 123 4.0_real64 ) . eq . 123 4.0_real64 , 123 4.0_real64 ) call unit_check ( 'anyscalar_to_real' , anyscalar_to_real ( 123 4.0_real128 ) . eq . 123 4.0_real128 , 123 4.0_real128 ) call unit_check_done ( 'anyscalar_to_real' , msg = '' ) end subroutine test_anyscalar_to_real !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_anything_to_bytes () call unit_check_start ( 'anything_to_bytes' , msg = '' ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int8 )) . eq . transfer ( huge ( 0_int8 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int16 )) . eq . transfer ( huge ( 0_int16 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int32 )) . eq . transfer ( huge ( 0_int32 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0_int64 )) . eq . transfer ( huge ( 0_int64 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real32 )) . eq . transfer ( huge ( 0.0_real32 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real64 )) . eq . transfer ( huge ( 0.0_real64 ), 'A' )) ) call unit_check ( 'anything_to_bytes' , any ( anything_to_bytes ( huge ( 0.0_real128 )) . eq . transfer ( huge ( 0.0_real128 ), 'A' )) ) call unit_check_done ( 'anything_to_bytes' , msg = '' ) end subroutine test_anything_to_bytes !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_empty !!use M_anything, only : empty, assignment(=) implicit none doubleprecision , allocatable :: d (:) integer , allocatable :: i (:) real , allocatable :: r (:) character ( len = :), allocatable :: c (:) integer , allocatable :: ints (:) character (:), allocatable :: strs (:) integer :: answer call unit_check_start ( 'empty' ) !  register an entry for specified name in database with status of zero (0) d = empty r = empty i = empty c = empty call unit_check ( 'empty' , size ( d ). eq . 0 , 'checking double' ) call unit_check ( 'empty' , size ( r ). eq . 0 , 'checking real' ) call unit_check ( 'empty' , size ( i ). eq . 0 , 'checking integer' ) call unit_check ( 'empty' , size ( c ). eq . 0 , 'checking character' ) ints = empty answer = 0 call check_ints ( answer , ints ) ints = [ 1 , 2 , 3 ] answer = 3 call check_ints ( answer , ints ) call unit_check ( 'empty' , all ( ints . eq .[ 1 , 2 , 3 ]), msg = 'normal allocation' ) ints = empty answer = 0 call check_ints ( answer , ints ) strs = empty answer = 0 call check_strs ( answer , strs ) strs = [ \"apple\" , \"orang\" , \"banan\" ] answer = 3 call check_strs ( answer , strs ) call unit_check ( 'empty' , all ( strs . eq .[ \"apple\" , \"orang\" , \"banan\" ]), msg = 'normal allocation' ) strs = empty answer = 0 call check_strs ( answer , strs ) call unit_check_done ( 'empty' ) end subroutine test_empty !----------------------------------------------------------------------------------------------------------------------------------- subroutine check_ints ( answer , ints ) integer , intent ( in ), allocatable :: ints (:) integer , intent ( in ) :: answer !  if mask test fails, change database status for specified entry to -1 and stop program, else continue if ( allocated ( ints )) then call unit_check ( 'empty' , size ( ints ). eq . answer , 'size is' , answer ) endif end subroutine check_ints !----------------------------------------------------------------------------------------------------------------------------------- subroutine check_strs ( answer , strs ) integer , intent ( in ) :: answer character ( len = :), allocatable , intent ( in ) :: strs (:) integer k if ( allocated ( strs ) ) then if ( unit_check_level . gt . 0 ) then print * , \"strs: val = \" , ( strs ( k ) // \" \" , k = 1 , size ( strs ) ) print * , \"      len_elem = \" , len ( strs ( 1 )) endif call unit_check ( 'empty' , size ( strs ). eq . answer , 'size is' , answer ) endif end subroutine check_strs !----------------------------------------------------------------------------------------------------------------------------------- end subroutine test_suite_M_anything","tags":"","loc":"proc/test_suite_m_anything.html"},{"title":"M_anything – M_anything","text":"NAME M_anything(3fm) - [M_anything::INTRO] procedures that use polymorphism to allow arguments of different types generically\n(LICENSE:MIT) SYNOPSIS use M_anything,only : anyinteger_to_string\n   use M_anything,only : anyscalar_to_int64\n   use M_anything,only : anyscalar_to_real\n   use M_anything,only : anyscalar_to_real128\n   use M_anything,only : anyscalar_to_double\n   use M_anything,only : anything_to_bytes\n   use M_anything,only : bytes_to_anything\n   use M_anything,only : empty, assignment(=) DESCRIPTION anyinteger_to_string    convert integer parameter of any kind to string\nanyscalar_to_int64      convert integer parameter of any kind to 64-bit integer\nanyscalar_to_real       convert integer or real parameter of any kind to real\nanyscalar_to_real128    convert integer or real parameter of any kind to real128\nanyscalar_to_double     convert integer or real parameter of any kind to doubleprecision\nanything_to_bytes       convert anything to bytes\nempty                   create an empty array EXAMPLE At the cost of casting to a different type these functions can\n (among other uses such as in linked lists) allow for an alternative\n to duplicating code using generic procedure methods. For example,\n the following SQUAREALL function can take many input types and return a\n DOUBLEPRECISION value (it is a trivial example for demonstration purposes,\n and does not check for overflow, etc.).: Sample program program demo_anyscalar_to_double use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squareall ( 2 _int8 ) write ( * , * ) squareall ( 2 _int16 ) write ( * , * ) squareall ( 2 _int32 ) write ( * , * ) squareall ( 2 _int64 ) write ( * , * ) squareall ( 2 . 0 _real32 ) write ( * , * ) squareall ( 2 . 0 _real64 ) write ( * , * ) squareall ( 2 . 0 _real128 ) contains function squareall ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ) , intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squareall end program demo_anyscalar_to_double Results: 4.00000000000000\n   4.00000000000000\n   4.00000000000000\n   4.00000000000000\n   4.00000000000000\n   4.00000000000000\n   4.00000000000000 AUTHOR John S. Urban LICENSE MIT public setany subroutine setany(anything,default,answer)\nimplicit none $@(#) M_anything::setany(3fp): set absent parameter to default value class( ),intent(in),optional     :: anything\nclass( ),intent(in)              :: default\nclass(*),intent(out),allocatable :: answer\nif(present(anything))then\n   answer=anything\nelse\n   answer=default\nendif\nend subroutine setany Uses iso_fortran_env Contents Variables empty Interfaces anything_to_bytes assignment(=) Functions anyinteger_to_string anyscalar_to_double anyscalar_to_int64 anyscalar_to_real anyscalar_to_real128 Subroutines bytes_to_anything Variables Type Visibility Attributes Name Initial type(Empty_t), public :: empty singleton Interfaces public interface anything_to_bytes private function anything_to_bytes_arr(anything) result(chars) Sample program Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) Return Value character(len=1),allocatable, (:) private function anything_to_bytes_scalar(anything) result(chars) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything Return Value character(len=1),allocatable, (:) public interface assignment(=) private subroutine ints_empty_(x, emp) Sample program: Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private subroutine reals_empty_(x, emp) Arguments Type Intent Optional Attributes Name real, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private subroutine doubles_empty_(x, emp) Arguments Type Intent Optional Attributes Name doubleprecision, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp private subroutine strings_empty_(x, emp) Arguments Type Intent Optional Attributes Name character, intent(inout), allocatable :: x (:) type(Empty_t), intent(in) :: emp Functions public impure function anyinteger_to_string (int) result(out) Sample program Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: int Return Value character(len=:),allocatable public pure elemental function anyscalar_to_double (valuein) result(d_out) Sample program Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value doubleprecision public impure elemental function anyscalar_to_int64 (valuein) result(ii38) Results Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value integer(kind=int64) public pure elemental function anyscalar_to_real (valuein) result(r_out) Sample program Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value real public pure elemental function anyscalar_to_real128 (valuein) result(d_out) Sample program Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: valuein Return Value real(kind=real128) Subroutines public subroutine bytes_to_anything (chars, anything) subroutine bytes_to_anything(chars,anything) Read more… Arguments Type Intent Optional Attributes Name character(len=1), allocatable :: chars (:) class(*) :: anything","tags":"","loc":"module/m_anything.html"},{"title":"M_test_suite_M_anything – M_anything","text":"Uses M_verify M_anything iso_fortran_env M_msg Contents Subroutines test_suite_M_anything Subroutines public subroutine test_suite_M_anything () setup\nteardown Arguments None","tags":"","loc":"module/m_test_suite_m_anything.html"},{"title":"scalars – M_anything","text":"Uses M_anything iso_fortran_env THIS FUNCTION CAN TAKE AN INTEGER OR REAL OF ANY TYPE KNOWN TO ANYSCALAR_TO_REAL() AS AN ARGUMENT Contents Variables ios large medium rl rm rs small tiny Functions squarei Source Code scalars Variables Type Attributes Name Initial integer :: ios integer(kind=int64) :: large = huge(0_int64) integer(kind=int32) :: medium = huge(0_int32) real(kind=real128) :: rl = huge(0.0_real128) real(kind=real64) :: rm = huge(0.0_real64) real(kind=real32) :: rs = huge(0.0_real32) integer(kind=int16) :: small = huge(0_int16) integer(kind=int8) :: tiny = huge(0_int8) Functions function squarei (invalue) result(dvalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value real Source Code program scalars use M_anything , only : anyscalar_to_real use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none integer :: ios integer ( kind = int8 ) :: tiny = huge ( 0_int8 ) integer ( kind = int16 ) :: small = huge ( 0_int16 ) integer ( kind = int32 ) :: medium = huge ( 0_int32 ) integer ( kind = int64 ) :: large = huge ( 0_int64 ) real ( kind = real32 ) :: rs = huge ( 0.0_real32 ) real ( kind = real64 ) :: rm = huge ( 0.0_real64 ) real ( kind = real128 ) :: rl = huge ( 0.0_real128 ) 101 format ( a10 , \"|\" , i39 , \"|\" , i11 , \"|\" , i39 ) 102 format ( a10 , \"|\" , g0 , t55 , \"|\" , i11 , \"|\" , g0 ) write ( * , * ) 'First show the intrinsic variables of various KINDS we will be using' write ( * , * ) '  NAME   |VALUE                                  |KIND(VALUE)|10**RANGE(VALUE)' write ( * , 102 ) 'rs     ' , rs , kind ( rs ), 1 0.0_real32 ** range ( rs ) write ( * , 102 ) 'rm     ' , rm , kind ( rm ), 1 0.0_real64 ** range ( rm ) write ( * , 102 ) 'rl     ' , rl , kind ( rl ), 1 0.0_real128 ** range ( rl ) write ( * , 102 ) 'tiny   ' , tiny , kind ( tiny ) write ( * , 102 ) 'small  ' , small , kind ( small ) write ( * , 102 ) 'medium ' , medium , kind ( medium ) write ( * , 102 ) 'large  ' , large , kind ( large ) write ( * , * ) 'Test squarei with all INTEGER KINDs:' write ( * , * ) '(and given the following facts what is the expected output?)' write ( * , * ) 'FACTS:' write ( * , * ) '127 * 127 = 16129' write ( * , * ) '32767 * 32767 = 1073676289' write ( * , * ) '2147483647 * 2147483647 = 4611686014132420609' write ( * , * ) '9223372036854775807 * 9223372036854775807 = 85070591730234615847396907784232501249' write ( * , * ) '170141183460469231731687303715884105727 * 170141183460469231731687303715884105727 =& &28948022309329048855892746252171976962977213799489202546401021394546514198529' write ( * , * ) 'OUTPUT:' 202 format ( a , * ( g0 :, '; ' )) write ( * , 202 , iostat = ios ) 'SQUAREI()  :' , squarei ( tiny ), squarei ( small ), squarei ( medium ), squarei ( large ) write ( * , 202 , iostat = ios ) 'SQUAREI()  :' , squarei ( rs ), squarei ( rm ), squarei ( rl ) contains !! THIS FUNCTION CAN TAKE AN INTEGER OR REAL OF ANY TYPE KNOWN TO ANYSCALAR_TO_REAL() AS AN ARGUMENT function squarei ( invalue ) result ( dvalue ) ! square an integer value generically use M_anything , only : anyscalar_to_real implicit none class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue real , parameter :: biggest = sqrt ( real ( 0.0 , kind = real128 )) invalue_local = anyscalar_to_real ( invalue ) !if(invalue_local.gt.biggest)then !   write(*,*)'ERROR:*squarei* input value to big=',invalue_local !endif dvalue = invalue_local * invalue_local end function squarei end program scalars","tags":"","loc":"program/scalars.html"},{"title":"demo_anyscalar_to_double – M_anything","text":"Uses iso_fortran_env Contents Functions squareall Source Code demo_anyscalar_to_double Functions function squareall (invalue) result(dvalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Source Code program demo_anyscalar_to_double use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squareall ( 2_int8 ) write ( * , * ) squareall ( 2_int16 ) write ( * , * ) squareall ( 2_int32 ) write ( * , * ) squareall ( 2_int64 ) write ( * , * ) squareall ( 2.0_real32 ) write ( * , * ) squareall ( 2.0_real64 ) write ( * , * ) squareall ( 2.0_real128 ) contains function squareall ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squareall end program demo_anyscalar_to_double","tags":"","loc":"program/demo_anyscalar_to_double.html"},{"title":"demo_anyscalar_to_real128 – M_anything","text":"Uses iso_fortran_env Contents Functions squarei Source Code demo_anyscalar_to_real128 Functions function squarei (invalue) result(dvalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value real(kind=real128) Source Code program demo_anyscalar_to_real128 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2_int8 ) write ( * , * ) squarei ( 2_int16 ) write ( * , * ) squarei ( 2_int32 ) write ( * , * ) squarei ( 2_int64 ) write ( * , * ) squarei ( 2.0_real32 ) write ( * , * ) squarei ( 2.0_real64 ) write ( * , * ) squarei ( 2.0_real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real128 class ( * ), intent ( in ) :: invalue real ( kind = real128 ) :: invalue_local real ( kind = real128 ) :: dvalue invalue_local = anyscalar_to_real128 ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_real128","tags":"","loc":"program/demo_anyscalar_to_real128.html"},{"title":"demo_empty_ – M_anything","text":"Uses M_anything Contents Variables ints reals strs Source Code demo_empty_ Variables Type Attributes Name Initial integer, allocatable :: ints (:) real, allocatable :: reals (:) character, allocatable :: strs (:) Source Code program demo_empty_ use M_anything , only : empty , assignment ( = ) integer , allocatable :: ints (:) character (:), allocatable :: strs (:) real , allocatable :: reals (:) ints = empty write ( * , * ) size ( ints ) write ( * , * ) 'give them some size ...' reals = [ 1.0 , 2.0 , 3.0 ] ints = [ 1 , 2 , 3 ] strs = [ character ( len = 10 ) :: \"one\" , \"two\" , \"three\" , \"four\" ] write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) ints = empty reals = empty strs = empty write ( * , * ) 'back to empty ...' write ( * , * ) size ( ints ) write ( * , * ) size ( reals ) write ( * , * ) size ( strs ) end program demo_empty_","tags":"","loc":"program/demo_empty_.html"},{"title":"demo_anyscalar_to_int64 – M_anything","text":"Uses iso_fortran_env Contents Functions squarei Source Code demo_anyscalar_to_int64 Functions function squarei (invalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Source Code program demo_anyscalar_to_int64 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( huge ( 0_int8 )), huge ( 0_int8 ) , & & '16129' write ( * , * ) squarei ( huge ( 0_int16 )), huge ( 0_int16 ) , & & '1073676289' write ( * , * ) squarei ( huge ( 0_int32 )), huge ( 0_int32 ) , & & '4611686014132420609' write ( * , * ) squarei ( huge ( 0_int64 )), huge ( 0_int64 ) , & & '85070591730234615847396907784232501249' contains ! function squarei ( invalue ) use M_anything , only : anyscalar_to_int64 class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: squarei invalue_local = anyscalar_to_int64 ( invalue ) squarei = invalue_local * invalue_local end function squarei ! end program demo_anyscalar_to_int64","tags":"","loc":"program/demo_anyscalar_to_int64.html"},{"title":"demo_anyscalar_to_double – M_anything","text":"Uses iso_fortran_env Contents Functions squarei Source Code demo_anyscalar_to_double Functions function squarei (invalue) result(dvalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value doubleprecision Source Code program demo_anyscalar_to_double use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2_int8 ) write ( * , * ) squarei ( 2_int16 ) write ( * , * ) squarei ( 2_int32 ) write ( * , * ) squarei ( 2_int64 ) write ( * , * ) squarei ( 2.0_real32 ) write ( * , * ) squarei ( 2.0_real64 ) write ( * , * ) squarei ( 2.0_real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_double class ( * ), intent ( in ) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local = anyscalar_to_double ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_double","tags":"","loc":"program/demo_anyscalar_to_double~2.html"},{"title":"demo_anything_to_bytes – M_anything","text":"Uses M_anything use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nuse, intrinsic :: iso_fortran_env, only : real32, real64, real128 Contents Variables i Source Code demo_anything_to_bytes Variables Type Attributes Name Initial integer :: i Source Code program demo_anything_to_bytes use M_anything , only : anything_to_bytes !!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!use, intrinsic :: iso_fortran_env, only : real32, real64, real128 implicit none integer :: i write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ([( i * i , i = 1 , 10 )]) write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ([ 1 1.11 , 2 2.22 , 3 3.33 ]) write ( * , '(/,4(1x,z2.2))' ) anything_to_bytes ( 'This is a string' ) end program demo_anything_to_bytes","tags":"","loc":"program/demo_anything_to_bytes.html"},{"title":"demo_anyinteger_to_string – M_anything","text":"Uses M_anything iso_fortran_env Contents Source Code demo_anyinteger_to_string Source Code program demo_anyinteger_to_string use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use M_anything , only : itoc => anyinteger_to_string implicit none write ( * , * ) itoc ( huge ( 0_int8 )), '=> 127' write ( * , * ) itoc ( huge ( 0_int16 )), '=> 32767' write ( * , * ) itoc ( huge ( 0_int32 )), '=> 2147483647' write ( * , * ) itoc ( huge ( 0_int64 )), '=> 9223372036854775807' , huge ( 0_int64 ) write ( * , * ) itoc ( - ( huge ( 0_int64 ) - 1 )), '=> -9223372036854775806' end program demo_anyinteger_to_string","tags":"","loc":"program/demo_anyinteger_to_string.html"},{"title":"demo_anyscalar_to_real – M_anything","text":"Uses iso_fortran_env Contents Functions squarei Source Code demo_anyscalar_to_real Functions function squarei (invalue) result(dvalue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: invalue Return Value real Source Code program demo_anyscalar_to_real use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none ! call same function with many scalar input types write ( * , * ) squarei ( 2_int8 ) write ( * , * ) squarei ( 2_int16 ) write ( * , * ) squarei ( 2_int32 ) write ( * , * ) squarei ( 2_int64 ) write ( * , * ) squarei ( 2.0_real32 ) write ( * , * ) squarei ( 2.0_real64 ) write ( * , * ) squarei ( 2.0_real128 ) contains function squarei ( invalue ) result ( dvalue ) use M_anything , only : anyscalar_to_real class ( * ), intent ( in ) :: invalue real :: invalue_local real :: dvalue invalue_local = anyscalar_to_real ( invalue ) dvalue = invalue_local * invalue_local end function squarei end program demo_anyscalar_to_real","tags":"","loc":"program/demo_anyscalar_to_real.html"},{"title":"runtest – M_anything","text":"Uses M_verify M_test_suite_M_anything M_msg Contents Source Code runtest Source Code program runtest use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level , unit_check_stop use M_test_suite_M_anything implicit none unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_anything () call unit_check_stop () end program runtest","tags":"","loc":"program/runtest.html"}]}