<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M_anything: m_anything Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">M_anything
   </div>
   <div id="projectbrief">M_anything module (Fortran)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">m_anything Module Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__anything_1_1anything__to__bytes.html">anything_to_bytes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__anything_1_1assignment_07_0a_08.html">assignment(=)</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structm__anything_1_1empty__t.html">empty_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__anything_1_1get__type.html">get_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:afcfe05dc22180128691b5a927a18e128"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#afcfe05dc22180128691b5a927a18e128">ints_empty_</a> (x, emp)</td></tr>
<tr class="separator:afcfe05dc22180128691b5a927a18e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194a83c578ddeb7ddea8f1104c874f1f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#a194a83c578ddeb7ddea8f1104c874f1f">doubles_empty_</a> (x, emp)</td></tr>
<tr class="separator:a194a83c578ddeb7ddea8f1104c874f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f08daae5d997da54974e6ccf14bb51"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#ad1f08daae5d997da54974e6ccf14bb51">reals_empty_</a> (x, emp)</td></tr>
<tr class="separator:ad1f08daae5d997da54974e6ccf14bb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8626e75d3bb98d3c1a7ead89e334719f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#a8626e75d3bb98d3c1a7ead89e334719f">strings_empty_</a> (x, emp)</td></tr>
<tr class="separator:a8626e75d3bb98d3c1a7ead89e334719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426ed79921650d9d1c8f9308b31f0f65"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#a426ed79921650d9d1c8f9308b31f0f65">bytes_to_anything</a> (chars, anything)</td></tr>
<tr class="separator:a426ed79921650d9d1c8f9308b31f0f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac00e86ef2d96db48851045b2cd662c"><td class="memItemLeft" align="right" valign="top">character(len=1) function, dimension(:), allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#a6ac00e86ef2d96db48851045b2cd662c">anything_to_bytes_arr</a> (anything)</td></tr>
<tr class="separator:a6ac00e86ef2d96db48851045b2cd662c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9522ae9993fae25ef5e1cc181cebe38"><td class="memItemLeft" align="right" valign="top">character(len=1) function, dimension(:), allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#ad9522ae9993fae25ef5e1cc181cebe38">anything_to_bytes_scalar</a> (anything)</td></tr>
<tr class="separator:ad9522ae9993fae25ef5e1cc181cebe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438e3f736473850fe065d5b8f94fefb5"><td class="memItemLeft" align="right" valign="top">pure elemental real(kind=real128) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#a438e3f736473850fe065d5b8f94fefb5">anyscalar_to_real128</a> (valuein)</td></tr>
<tr class="separator:a438e3f736473850fe065d5b8f94fefb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c58e9d734944f29fbe87c696f5839c5"><td class="memItemLeft" align="right" valign="top">pure elemental doubleprecision function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#a2c58e9d734944f29fbe87c696f5839c5">anyscalar_to_double</a> (valuein)</td></tr>
<tr class="separator:a2c58e9d734944f29fbe87c696f5839c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57576a4baf147b3e89b20d679438d8d9"><td class="memItemLeft" align="right" valign="top">pure elemental real function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#a57576a4baf147b3e89b20d679438d8d9">anyscalar_to_real</a> (valuein)</td></tr>
<tr class="separator:a57576a4baf147b3e89b20d679438d8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1527db0215a5a8a20c015c48b8ebc9"><td class="memItemLeft" align="right" valign="top">impure elemental integer(kind=int64) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#aba1527db0215a5a8a20c015c48b8ebc9">anyscalar_to_int64</a> (valuein)</td></tr>
<tr class="separator:aba1527db0215a5a8a20c015c48b8ebc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e57496a414542d4d5d58e6786b8ace"><td class="memItemLeft" align="right" valign="top">impure character(len=:) function, allocatable, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#ab5e57496a414542d4d5d58e6786b8ace">anyinteger_to_string</a> (int)</td></tr>
<tr class="separator:ab5e57496a414542d4d5d58e6786b8ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7af75ce1cc8021220d97b9ebc7a7f37"><td class="memItemLeft" align="right" valign="top">character(len=20) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#af7af75ce1cc8021220d97b9ebc7a7f37">get_type_arr</a> (anything)</td></tr>
<tr class="separator:af7af75ce1cc8021220d97b9ebc7a7f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68f8a3661bee024f1887d5352d3c56c"><td class="memItemLeft" align="right" valign="top">elemental impure character(len=20) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#ab68f8a3661bee024f1887d5352d3c56c">get_type_scalar</a> (anything)</td></tr>
<tr class="separator:ab68f8a3661bee024f1887d5352d3c56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab7b5587f91426df3cf07dc2395f209e9"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#ab7b5587f91426df3cf07dc2395f209e9">dp</a> =kind(0.0d0)</td></tr>
<tr class="separator:ab7b5587f91426df3cf07dc2395f209e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9652370cd85a527e9eafbb3987bc3d"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__anything_1_1empty__t.html">empty_t</a>), public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__anything.html#a6f9652370cd85a527e9eafbb3987bc3d">empty</a></td></tr>
<tr class="separator:a6f9652370cd85a527e9eafbb3987bc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h2><a class="anchor" id="autotoc_md0"></a>
NAME</h2>
<p>M_anything(3fm) - [M_anything::INTRO] procedures that use polymorphism to allow arguments of different types generically (LICENSE:MIT)</p>
<h2><a class="anchor" id="autotoc_md1"></a>
SYNOPSIS</h2>
<p>use M_anything,only : anyinteger_to_string use M_anything,only : anyscalar_to_int64 use M_anything,only : anyscalar_to_real use M_anything,only : anyscalar_to_real128 use M_anything,only : anyscalar_to_double use M_anything,only : <a class="el" href="interfacem__anything_1_1anything__to__bytes.html">anything_to_bytes</a> use M_anything,only : <a class="el" href="interfacem__anything_1_1get__type.html">get_type</a> use M_anything,only : bytes_to_anything use M_anything,only : empty, assignment(=)</p>
<h2><a class="anchor" id="autotoc_md2"></a>
DESCRIPTION</h2>
<p>anyinteger_to_string convert integer parameter of any kind to string anyscalar_to_int64 convert integer or real of any kind to 64-bit integer anyscalar_to_real convert integer or real of any kind to real anyscalar_to_real128 convert integer or real of any kind to real128 anyscalar_to_double convert integer or real of any kind to doubleprecision <a class="el" href="interfacem__anything_1_1anything__to__bytes.html">anything_to_bytes</a> convert anything to bytes <a class="el" href="interfacem__anything_1_1get__type.html">get_type</a> return array of strings containing type names of arguments empty create an empty array</p>
<h2><a class="anchor" id="autotoc_md3"></a>
EXAMPLE</h2>
<p>At the cost of casting to a different type these functions can (among other uses such as in linked lists) allow for an alternative to duplicating code using generic procedure methods. For example, the following SQUAREALL function can take many input types and return a DOUBLEPRECISION value (it is a trivial example for demonstration purposes, and does not check for overflow, etc.).:</p>
<p>Sample program</p>
<p>program demo_anyscalar_to_double use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 use, intrinsic :: iso_fortran_env, only : real32, real64, real128 implicit none ! call same function with many scalar input types write(*,*)squareall(2_int8) write(*,*)squareall(2_int16) write(*,*)squareall(2_int32) write(*,*)squareall(2_int64) write(*,*)squareall(2.0_real32) write(*,*)squareall(2.0_real64) write(*,*)squareall(2.0_real128) contains</p>
<p>function squareall(invalue) result (dvalue) use M_anything, only : anyscalar_to_double class(*),intent(in) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local=anyscalar_to_double(invalue) dvalue=invalue_local*invalue_local end function squareall</p>
<p>end program demo_anyscalar_to_double</p>
<p>Results: </p><pre class="fragment">4.00000000000000
4.00000000000000
4.00000000000000
4.00000000000000
4.00000000000000
4.00000000000000
4.00000000000000
</pre><h2><a class="anchor" id="autotoc_md4"></a>
AUTHOR</h2>
<p>John S. Urban</p>
<h2><a class="anchor" id="autotoc_md5"></a>
LICENSE</h2>
<p>MIT </p>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="ab5e57496a414542d4d5d58e6786b8ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e57496a414542d4d5d58e6786b8ace">&#9670;&nbsp;</a></span>anyinteger_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">impure character(len=:) function, allocatable, public m_anything::anyinteger_to_string </td>
          <td>(</td>
          <td class="paramtype">class(*), intent(in)&#160;</td>
          <td class="paramname"><em>int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md60"></a>
NAME</h2>
<pre class="fragment">anyinteger_to_string(3f) - [M_anything] convert integer of any kind to a string
(LICENSE:MIT)
</pre><h2><a class="anchor" id="autotoc_md61"></a>
SYNOPSIS</h2>
<pre class="fragment">impure function anyinteger_to_string(intin) result(str)

 character(len=:),allocatable :: anyinteger_to_string
 class(*),intent(in)          :: intin
</pre><h2><a class="anchor" id="autotoc_md62"></a>
DESCRIPTION</h2>
<pre class="fragment">Converts an integer value to a string representing the value.
This function allows arguments of different INTEGER types as input.
</pre><h2><a class="anchor" id="autotoc_md63"></a>
OPTIONS</h2>
<pre class="fragment">VALUEIN  INTEGER input argument to be converted to a string.
         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64.
</pre><h2><a class="anchor" id="autotoc_md64"></a>
RESULTS</h2>
<p>The value of VALUIN converted to a CHARACTER string.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
EXAMPLE</h2>
<p>Sample program</p>
<p>program demo_anyinteger_to_string use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 use M_anything, only : itoc=&gt;anyinteger_to_string implicit none write(*,*)itoc(huge(0_int8)), '=&gt; 127' write(*,*)itoc(huge(0_int16)), '=&gt; 32767' write(*,*)itoc(huge(0_int32)), '=&gt; 2147483647' write(*,*)itoc(huge(0_int64)), '=&gt; 9223372036854775807',huge(0_int64) write(*,*)itoc(-(huge(0_int64)-1)), '=&gt; -9223372036854775806' end program demo_anyinteger_to_string</p>
<p>Results:</p>
<p>127=&gt; 127 32767=&gt; 32767 2147483647=&gt; 2147483647 9223372036854775807=&gt; 9223372036854775807 -9223372036854775806=&gt; -9223372036854775806</p>
<h2><a class="anchor" id="autotoc_md66"></a>
AUTHOR</h2>
<p>John S. Urban</p>
<h2><a class="anchor" id="autotoc_md67"></a>
LICENSE</h2>
<p>MIT </p>

<p class="reference">References <a class="el" href="namespacem__anything.html#aba1527db0215a5a8a20c015c48b8ebc9">anyscalar_to_int64()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__anything_ab5e57496a414542d4d5d58e6786b8ace_cgraph.png" border="0" usemap="#namespacem__anything_ab5e57496a414542d4d5d58e6786b8ace_cgraph" alt=""/></div>
<map name="namespacem__anything_ab5e57496a414542d4d5d58e6786b8ace_cgraph" id="namespacem__anything_ab5e57496a414542d4d5d58e6786b8ace_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,183,47"/>
<area shape="rect" href="namespacem__anything.html#aba1527db0215a5a8a20c015c48b8ebc9" title=" " alt="" coords="231,5,401,47"/>
</map>
</div>

</div>
</div>
<a id="a2c58e9d734944f29fbe87c696f5839c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c58e9d734944f29fbe87c696f5839c5">&#9670;&nbsp;</a></span>anyscalar_to_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure elemental doubleprecision function, public m_anything::anyscalar_to_double </td>
          <td>(</td>
          <td class="paramtype">class(*), intent(in)&#160;</td>
          <td class="paramname"><em>valuein</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md36"></a>
NAME</h2>
<p>anyscalar_to_double(3f) - [M_anything] convert integer or real parameter of any kind to doubleprecision (LICENSE:MIT)</p>
<h2><a class="anchor" id="autotoc_md37"></a>
SYNOPSIS</h2>
<pre class="fragment">pure elemental function anyscalar_to_double(valuein) result(d_out)

 class(*),intent(in)  :: valuein
 doubleprecision      :: d_out
</pre><h2><a class="anchor" id="autotoc_md38"></a>
DESCRIPTION</h2>
<pre class="fragment">This function uses polymorphism to allow input arguments of different
types. It is used to create other procedures that can take many
scalar arguments as input options.
</pre><h2><a class="anchor" id="autotoc_md39"></a>
OPTIONS</h2>
<pre class="fragment">VALUEIN  input argument of a procedure to convert to type DOUBLEPRECISION.
         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64,
         kind=real32, kind=real64, or kind=real128
</pre><h2><a class="anchor" id="autotoc_md40"></a>
RESULTS</h2>
<pre class="fragment">D_OUT    The value of VALUIN converted to doubleprecision (assuming
         it is actually in the range of type DOUBLEPRECISION).
</pre><h2><a class="anchor" id="autotoc_md41"></a>
EXAMPLE</h2>
<p>Sample program</p>
<p>program demo_anyscalar_to_double use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 use, intrinsic :: iso_fortran_env, only : real32, real64, real128 implicit none ! call same function with many scalar input types write(*,*)squarei(2_int8) write(*,*)squarei(2_int16) write(*,*)squarei(2_int32) write(*,*)squarei(2_int64) write(*,*)squarei(2.0_real32) write(*,*)squarei(2.0_real64) write(*,*)squarei(2.0_real128) contains</p>
<p>function squarei(invalue) result (dvalue) use M_anything, only : anyscalar_to_double class(*),intent(in) :: invalue doubleprecision :: invalue_local doubleprecision :: dvalue invalue_local=anyscalar_to_double(invalue) dvalue=invalue_local*invalue_local end function squarei</p>
<p>end program demo_anyscalar_to_double</p>
<h2><a class="anchor" id="autotoc_md42"></a>
AUTHOR</h2>
<p>John S. Urban</p>
<h2><a class="anchor" id="autotoc_md43"></a>
LICENSE</h2>
<p>MIT </p>

</div>
</div>
<a id="aba1527db0215a5a8a20c015c48b8ebc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1527db0215a5a8a20c015c48b8ebc9">&#9670;&nbsp;</a></span>anyscalar_to_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">impure elemental integer(kind=int64) function, public m_anything::anyscalar_to_int64 </td>
          <td>(</td>
          <td class="paramtype">class(*), intent(in)&#160;</td>
          <td class="paramname"><em>valuein</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md52"></a>
NAME</h2>
<pre class="fragment">anyscalar_to_int64(3f) - [M_anything] convert integer any kind to integer(kind=int64)
(LICENSE:MIT)
</pre><h2><a class="anchor" id="autotoc_md53"></a>
SYNOPSIS</h2>
<pre class="fragment">impure elemental function anyscalar_to_int64(intin) result(value)

 class(*),intent(in) :: intin
 integer(kind=int64) :: value
</pre><h2><a class="anchor" id="autotoc_md54"></a>
DESCRIPTION</h2>
<pre class="fragment">This function uses polymorphism to allow arguments of different INTEGER types
as input. It is typically used to create other procedures that can take
many scalar arguments as input options, equivalent to passing the
parameter VALUE as int(VALUE,0_int64).
</pre><h2><a class="anchor" id="autotoc_md55"></a>
OPTIONS</h2>
<pre class="fragment">VALUEIN  input argument of a procedure to convert to type INTEGER(KIND=int64).
         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64.
</pre><h2><a class="anchor" id="autotoc_md56"></a>
RESULTS</h2>
<p>The value of VALUIN converted to INTEGER(KIND=INT64). </p>
<h2><a class="anchor" id="autotoc_md57"></a>
EXAMPLE</h2>
<pre class="fragment">Sample program

 program demo_anyscalar_to_int64
 use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
 implicit none
    ! call same function with many scalar input types
    write(*,*)squarei(huge(0_int8)),huge(0_int8) , &amp;
    &amp; '16129'
    write(*,*)squarei(huge(0_int16)),huge(0_int16) , &amp;
    &amp; '1073676289'
    write(*,*)squarei(huge(0_int32)),huge(0_int32) , &amp;
    &amp; '4611686014132420609'
    write(*,*)squarei(huge(0_int64)),huge(0_int64) , &amp;
    &amp; '85070591730234615847396907784232501249'
 contains
 !
 function squarei(invalue)
 use M_anything, only : anyscalar_to_int64
 class(*),intent(in)  :: invalue
 doubleprecision      :: invalue_local
 doubleprecision      :: squarei
    invalue_local=anyscalar_to_int64(invalue)
    squarei=invalue_local*invalue_local
 end function squarei
 !
 end program demo_anyscalar_to_int64
</pre><p>Results</p>
<p>16129.000000000000 127 \ 16129 1073676289.0000000 32767 \ 1073676289 4.6116860141324206E+018 2147483647 \ 4611686014132420609 8.5070591730234616E+037 9223372036854775807 \ 85070591730234615847396907784232501249 2.8948022309329049E+076 170141183460469231731687303715884105727 \ 28948022309329048855892746252171976962977213799489202546401021394546514198529</p>
<h2><a class="anchor" id="autotoc_md58"></a>
AUTHOR</h2>
<p>John S. Urban</p>
<h2><a class="anchor" id="autotoc_md59"></a>
LICENSE</h2>
<p>MIT </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacem__anything_aba1527db0215a5a8a20c015c48b8ebc9_icgraph.png" border="0" usemap="#namespacem__anything_aba1527db0215a5a8a20c015c48b8ebc9_icgraph" alt=""/></div>
<map name="namespacem__anything_aba1527db0215a5a8a20c015c48b8ebc9_icgraph" id="namespacem__anything_aba1527db0215a5a8a20c015c48b8ebc9_icgraph">
<area shape="rect" title=" " alt="" coords="231,5,401,47"/>
<area shape="rect" href="namespacem__anything.html#ab5e57496a414542d4d5d58e6786b8ace" title=" " alt="" coords="5,5,183,47"/>
</map>
</div>

</div>
</div>
<a id="a57576a4baf147b3e89b20d679438d8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57576a4baf147b3e89b20d679438d8d9">&#9670;&nbsp;</a></span>anyscalar_to_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure elemental real function, public m_anything::anyscalar_to_real </td>
          <td>(</td>
          <td class="paramtype">class(*), intent(in)&#160;</td>
          <td class="paramname"><em>valuein</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md44"></a>
NAME</h2>
<p>anyscalar_to_real(3f) - [M_anything] convert integer or real parameter of any kind to real (LICENSE:MIT)</p>
<h2><a class="anchor" id="autotoc_md45"></a>
SYNOPSIS</h2>
<pre class="fragment">pure elemental function anyscalar_to_real(valuein) result(r_out)

 class(*),intent(in)  :: valuein
 real                 :: r_out
</pre><h2><a class="anchor" id="autotoc_md46"></a>
DESCRIPTION</h2>
<pre class="fragment">This function uses polymorphism to allow input arguments of different types.
It is used to create other procedures that can take
many scalar arguments as input options.
</pre><h2><a class="anchor" id="autotoc_md47"></a>
OPTIONS</h2>
<pre class="fragment">VALUEIN  input argument of a procedure to convert to type REAL.
         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64,
         kind=real32, kind=real64, or kind=real128.
</pre><h2><a class="anchor" id="autotoc_md48"></a>
RESULTS</h2>
<pre class="fragment">R_OUT    The value of VALUIN converted to real (assuming it is actually
         in the range of type REAL).
</pre><h2><a class="anchor" id="autotoc_md49"></a>
EXAMPLE</h2>
<p>Sample program</p>
<p>program demo_anyscalar_to_real use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 use, intrinsic :: iso_fortran_env, only : real32, real64, real128 implicit none ! call same function with many scalar input types write(*,*)squarei(2_int8) write(*,*)squarei(2_int16) write(*,*)squarei(2_int32) write(*,*)squarei(2_int64) write(*,*)squarei(2.0_real32) write(*,*)squarei(2.0_real64) write(*,*)squarei(2.0_real128) contains</p>
<p>function squarei(invalue) result (dvalue) use M_anything, only : anyscalar_to_real class(*),intent(in) :: invalue real :: invalue_local real :: dvalue invalue_local=anyscalar_to_real(invalue) dvalue=invalue_local*invalue_local end function squarei</p>
<p>end program demo_anyscalar_to_real</p>
<h2><a class="anchor" id="autotoc_md50"></a>
AUTHOR</h2>
<p>John S. Urban</p>
<h2><a class="anchor" id="autotoc_md51"></a>
LICENSE</h2>
<p>MIT </p>

</div>
</div>
<a id="a438e3f736473850fe065d5b8f94fefb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438e3f736473850fe065d5b8f94fefb5">&#9670;&nbsp;</a></span>anyscalar_to_real128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure elemental real(kind=real128) function, public m_anything::anyscalar_to_real128 </td>
          <td>(</td>
          <td class="paramtype">class(*), intent(in)&#160;</td>
          <td class="paramname"><em>valuein</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md28"></a>
NAME</h2>
<p>anyscalar_to_real128(3f) - [M_anything] convert integer or real parameter of any kind to real128 (LICENSE:MIT)</p>
<h2><a class="anchor" id="autotoc_md29"></a>
SYNOPSIS</h2>
<pre class="fragment">pure elemental function anyscalar_to_real128(valuein) result(d_out)

 class(*),intent(in) :: valuein
 real(kind=128)      :: d_out
</pre><h2><a class="anchor" id="autotoc_md30"></a>
DESCRIPTION</h2>
<pre class="fragment">This function uses polymorphism to allow input arguments of different
types. It is used to create other procedures that can take many
scalar arguments as input options.
</pre><h2><a class="anchor" id="autotoc_md31"></a>
OPTIONS</h2>
<pre class="fragment">VALUEIN  input argument of a procedure to convert to type REAL128.
         May be of KIND kind=int8, kind=int16, kind=int32, kind=int64,
         kind=real32, kind=real64, or kind=real128
</pre><h2><a class="anchor" id="autotoc_md32"></a>
RESULTS</h2>
<pre class="fragment">D_OUT    The value of VALUIN converted to REAL128 (assuming
         it is actually in the range of type REAL128).
</pre><h2><a class="anchor" id="autotoc_md33"></a>
EXAMPLE</h2>
<p>Sample program</p>
<p>program demo_anyscalar_to_real128 use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 use, intrinsic :: iso_fortran_env, only : real32, real64, real128 implicit none ! call same function with many scalar input types write(*,*)squarei(2_int8) write(*,*)squarei(2_int16) write(*,*)squarei(2_int32) write(*,*)squarei(2_int64) write(*,*)squarei(2.0_real32) write(*,*)squarei(2.0_real64) write(*,*)squarei(2.0_real128) contains</p>
<p>function squarei(invalue) result (dvalue) use M_anything, only : anyscalar_to_real128 class(*),intent(in) :: invalue real(kind=real128) :: invalue_local real(kind=real128) :: dvalue invalue_local=anyscalar_to_real128(invalue) dvalue=invalue_local*invalue_local end function squarei</p>
<p>end program demo_anyscalar_to_real128</p>
<h2><a class="anchor" id="autotoc_md34"></a>
AUTHOR</h2>
<p>John S. Urban</p>
<h2><a class="anchor" id="autotoc_md35"></a>
LICENSE</h2>
<p>MIT </p>

</div>
</div>
<a id="a6ac00e86ef2d96db48851045b2cd662c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac00e86ef2d96db48851045b2cd662c">&#9670;&nbsp;</a></span>anything_to_bytes_arr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">character(len=1) function, dimension(:), allocatable m_anything::anything_to_bytes_arr </td>
          <td>(</td>
          <td class="paramtype">class(*), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>anything</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md20"></a>
NAME</h2>
<p>anything_to_bytes(3f) - [M_anything] convert standard types to bytes (character(len=1):: array(:)) (LICENSE:MIT)</p>
<h2><a class="anchor" id="autotoc_md21"></a>
SYNOPSIS</h2>
<pre class="fragment">function anything_to_bytes(anything) result(chars)

 class(*),intent(in)  :: anything
         or
 class(*),intent(in)  :: anything(:)

 character(len=1),allocatable :: chars(:)
</pre><h2><a class="anchor" id="autotoc_md22"></a>
DESCRIPTION</h2>
<pre class="fragment">This function uses polymorphism to allow input arguments of different
types. It is used to create other procedures that can take many
argument types as input options and convert them to a single type
to simplify storing arbitrary data, to simplify generating data
hashes, ...
</pre><h2><a class="anchor" id="autotoc_md23"></a>
OPTIONS</h2>
<pre class="fragment">VALUEIN  input array or scalar to convert to type CHARACTER(LEN=1).
         May be of KIND INTEGER(kind=int8), INTEGER(kind=int16),
         INTEGER(kind=int32), INTEGER(kind=int64),
         REAL(kind=real32, REAL(kind=real64),
         REAL(kind=real128), complex, or CHARACTER(len=*)
</pre> <h2><a class="anchor" id="autotoc_md24"></a>
RETURN</h2>
<pre class="fragment">CHARS    The returned value is an array of bytes (character(len=1)).
</pre><h2><a class="anchor" id="autotoc_md25"></a>
EXAMPLE</h2>
<p>Sample program</p>
<p>program demo_anything_to_bytes use M_anything, only : <a class="el" href="interfacem__anything_1_1anything__to__bytes.html">anything_to_bytes</a> !!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!use, intrinsic :: iso_fortran_env, only : real32, real64, real128 implicit none integer :: i write(*,'(/,4(1x,z2.2))')<a class="el" href="interfacem__anything_1_1anything__to__bytes.html">anything_to_bytes</a>([(i*i,i=1,10)]) write(*,'(/,4(1x,z2.2))')<a class="el" href="interfacem__anything_1_1anything__to__bytes.html">anything_to_bytes</a>([11.11,22.22,33.33]) write(*,'(/,4(1x,z2.2))')<a class="el" href="interfacem__anything_1_1anything__to__bytes.html">anything_to_bytes</a>('This is a string') end program demo_anything_to_bytes</p>
<p>Expected output </p><pre class="fragment"> 01 00 00 00
 04 00 00 00
 09 00 00 00
 10 00 00 00
 19 00 00 00
 24 00 00 00
 31 00 00 00
 40 00 00 00
 51 00 00 00
 64 00 00 00

 8F C2 31 41
 8F C2 B1 41
 EC 51 05 42

 54 68 69 73
 20 69 73 20
 61 20 73 74
 72 69 6E 67
</pre><h2><a class="anchor" id="autotoc_md26"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md27"></a>
LICENSE</h2>
<p>MIT </p>

</div>
</div>
<a id="ad9522ae9993fae25ef5e1cc181cebe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9522ae9993fae25ef5e1cc181cebe38">&#9670;&nbsp;</a></span>anything_to_bytes_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">character(len=1) function, dimension(:), allocatable m_anything::anything_to_bytes_scalar </td>
          <td>(</td>
          <td class="paramtype">class(*), intent(in)&#160;</td>
          <td class="paramname"><em>anything</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a426ed79921650d9d1c8f9308b31f0f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426ed79921650d9d1c8f9308b31f0f65">&#9670;&nbsp;</a></span>bytes_to_anything()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public m_anything::bytes_to_anything </td>
          <td>(</td>
          <td class="paramtype">character(len=1), dimension(:), allocatable&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(*)&#160;</td>
          <td class="paramname"><em>anything</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md12"></a>
NAME</h2>
<p>bytes_to_anything(3f) - [M_anything] convert bytes(character)len=1):: array(:)) to standard types (LICENSE:MIT)</p>
<h2><a class="anchor" id="autotoc_md13"></a>
SYNOPSIS</h2>
<p>subroutine bytes_to_anything(chars,anything)</p>
<p>character(len=1),allocatable :: chars(:) class(*) :: anything</p>
<h2><a class="anchor" id="autotoc_md14"></a>
DESCRIPTION</h2>
<pre class="fragment">This function uses polymorphism to allow input arguments of different
types. It is used to create other procedures that can take many
argument types as input options and convert them to a single type
to simplify storing arbitrary data, to simplify generating data
hashes, ...
</pre><h2><a class="anchor" id="autotoc_md15"></a>
OPTIONS</h2>
<p>CHARS The input value is an array of bytes (character(len=1)).</p>
<h2><a class="anchor" id="autotoc_md16"></a>
RETURN</h2>
<p>ANYTHING May be of KIND INTEGER(kind=int8), INTEGER(kind=int16), INTEGER(kind=int32), INTEGER(kind=int64), REAL(kind=real32, REAL(kind=real64), REAL(kind=real128), complex, or CHARACTER(len=*)</p>
<h2><a class="anchor" id="autotoc_md17"></a>
EXAMPLE</h2>
<p>Sample program</p>
<p>Expected output</p>
<h2><a class="anchor" id="autotoc_md18"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md19"></a>
LICENSE</h2>
<p>MIT </p>

</div>
</div>
<a id="a194a83c578ddeb7ddea8f1104c874f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194a83c578ddeb7ddea8f1104c874f1f">&#9670;&nbsp;</a></span>doubles_empty_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_anything::doubles_empty_ </td>
          <td>(</td>
          <td class="paramtype">doubleprecision, dimension(:), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__anything_1_1empty__t.html">empty_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>emp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7af75ce1cc8021220d97b9ebc7a7f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7af75ce1cc8021220d97b9ebc7a7f37">&#9670;&nbsp;</a></span>get_type_arr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">character(len=20) function m_anything::get_type_arr </td>
          <td>(</td>
          <td class="paramtype">class(*), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>anything</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md68"></a>
NAME</h2>
<p>get_type(3f) - [M_anything] return array of strings containing type names of arguments (LICENSE:MIT)</p>
<h2><a class="anchor" id="autotoc_md69"></a>
SYNOPSIS</h2>
<pre class="fragment">function get_type(anything) result(chars)

 class(*),intent(in)  :: anything
         or
 class(*),intent(in)  :: anything(..)

 character(len=:),allocatable :: chars
</pre><h2><a class="anchor" id="autotoc_md70"></a>
DESCRIPTION</h2>
<pre class="fragment">This function uses polymorphism to allow input arguments of different
types. It is used by other procedures that can take many
argument types as input options.
</pre><h2><a class="anchor" id="autotoc_md71"></a>
OPTIONS</h2>
<pre class="fragment">VALUEIN  input array or scalar to return type of
         May be of KIND INTEGER(kind=int8), INTEGER(kind=int16),
         INTEGER(kind=int32), INTEGER(kind=int64),
         REAL(kind=real32, REAL(kind=real64),
         REAL(kind=real128), complex, or CHARACTER(len=*)
</pre> <h2><a class="anchor" id="autotoc_md72"></a>
RETURN</h2>
<pre class="fragment">CHARS    The returned value is an array of names
</pre><h2><a class="anchor" id="autotoc_md73"></a>
EXAMPLE</h2>
<p>Sample program</p>
<p>program demo_get_type use M_anything, only : <a class="el" href="interfacem__anything_1_1get__type.html">get_type</a> implicit none integer :: i write(*,*)<a class="el" href="interfacem__anything_1_1get__type.html">get_type</a>([(i*i,i=1,10)]) write(*,*)<a class="el" href="interfacem__anything_1_1get__type.html">get_type</a>([11.11,22.22,33.33]) write(*,*)<a class="el" href="interfacem__anything_1_1get__type.html">get_type</a>('This is a string') write(*,*)<a class="el" href="interfacem__anything_1_1get__type.html">get_type</a>(30.0d0) end program demo_get_type</p>
<p>Results:</p>
<p>int32 real32 character real64</p>
<h2><a class="anchor" id="autotoc_md74"></a>
AUTHOR</h2>
<p>John S. Urban </p>
<h2><a class="anchor" id="autotoc_md75"></a>
LICENSE</h2>
<p>MIT </p>

</div>
</div>
<a id="ab68f8a3661bee024f1887d5352d3c56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68f8a3661bee024f1887d5352d3c56c">&#9670;&nbsp;</a></span>get_type_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">elemental impure character(len=20) function m_anything::get_type_scalar </td>
          <td>(</td>
          <td class="paramtype">class(*), intent(in)&#160;</td>
          <td class="paramname"><em>anything</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afcfe05dc22180128691b5a927a18e128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfe05dc22180128691b5a927a18e128">&#9670;&nbsp;</a></span>ints_empty_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_anything::ints_empty_ </td>
          <td>(</td>
          <td class="paramtype">integer, dimension(:), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__anything_1_1empty__t.html">empty_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>emp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md6"></a>
NAME</h2>
<p>empty(3f) - [M_anything] set an allocatable array to zero (LICENSE:MIT) </p>
<h2><a class="anchor" id="autotoc_md7"></a>
SYNOPSIS</h2>
<pre class="fragment">use M_anything, only : empty, assignment(=)
</pre> <h2><a class="anchor" id="autotoc_md8"></a>
DESCRIPTION</h2>
<p>A convenience routine that sets an array to an empty set. </p>
<h2><a class="anchor" id="autotoc_md9"></a>
EXAMPLE</h2>
<p>Sample program:</p>
<p>program demo_empty_ use M_anything, only : empty, assignment(=) integer, allocatable :: ints(:) character(:), allocatable :: strs(:) real, allocatable :: reals(:) ints=empty write(*,*)size(ints)</p>
<p>write(*,*)'give them some size ...' reals = [1.0,2.0,3.0] ints = [1,2,3] strs = [character(len=10) :: "one","two","three","four"] write(*,*)size(ints) write(*,*)size(reals) write(*,*)size(strs)</p>
<p>ints=empty reals=empty strs=empty write(*,*)'back to empty ...' write(*,*)size(ints) write(*,*)size(reals) write(*,*)size(strs)</p>
<p>end program demo_empty_</p>
<p>Expected output:</p>
<p>&gt; 0 &gt; give them some size ... &gt; 3 &gt; 3 &gt; 4 &gt; back to empty ... &gt; 0 &gt; 0 &gt; 0 </p>
<h2><a class="anchor" id="autotoc_md10"></a>
AUTHOR</h2>
<p>John S. Urban</p>
<h2><a class="anchor" id="autotoc_md11"></a>
LICENSE</h2>
<p>MIT </p>

</div>
</div>
<a id="ad1f08daae5d997da54974e6ccf14bb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f08daae5d997da54974e6ccf14bb51">&#9670;&nbsp;</a></span>reals_empty_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_anything::reals_empty_ </td>
          <td>(</td>
          <td class="paramtype">real, dimension(:), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__anything_1_1empty__t.html">empty_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>emp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8626e75d3bb98d3c1a7ead89e334719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8626e75d3bb98d3c1a7ead89e334719f">&#9670;&nbsp;</a></span>strings_empty_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_anything::strings_empty_ </td>
          <td>(</td>
          <td class="paramtype">character(:), dimension(:), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__anything_1_1empty__t.html">empty_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>emp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab7b5587f91426df3cf07dc2395f209e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b5587f91426df3cf07dc2395f209e9">&#9670;&nbsp;</a></span>dp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">integer, parameter m_anything::dp =kind(0.0d0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f9652370cd85a527e9eafbb3987bc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9652370cd85a527e9eafbb3987bc3d">&#9670;&nbsp;</a></span>empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__anything_1_1empty__t.html">empty_t</a>), public m_anything::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
